<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Qsys bus master</title>
</head>

<body>
<h2 align="center">DE1-SoC:
  Avalon bus master to HPS<br />
Cornell ece5760</h2>
<p>&nbsp;</p>
<h3>Avalon bus-master peripheral driving bus-slaves (with HPS read-out and control)</h3>
<p>General procedure for connecting EBAB:</p>
<ol>
  <li>Drag the EBAB module onto the Qsys layout</li>
  <li>Name it something reasonable</li>
  <li>Decide what bus-slaves the EBAB can communicate with and wire the EBAB Avalon-master output to the appropriate slave-input. </li>
  <li>Export the<em> external_interface</em> conduit connection and note the default name (or rename it).</li>
  <li>Generate the Qsys</li>
  <li>Go to the folder which contains the project <em>qpf file</em> (project description file)</li>
  <li>Navigate to the folder named <em>Computer_System</em> and find the file <em><a href="../HPS_FPGA/master_peripheral/Computer_System_inst.v">Computer_system_inst.v</a></em>. <br />
  This file contains the exported interface signals you need to connect to the EBAB from Verilog. The external signals you<br />
  need to generate/read are 
  to the right.<br />
  <pre>.ebab_video_in_external_interface_address     (connected-to-ebab_video_in_external_interface_address),   
.ebab_video_in_external_interface_byte_enable (connected-to-ebab_video_in_external_interface_byte_enable), 
.ebab_video_in_external_interface_read        (connected-to-ebab_video_in_external_interface_read),       
.ebab_video_in_external_interface_write       (connected-to-ebab_video_in_external_interface_write),      
.ebab_video_in_external_interface_write_data  (connected-to-ebab_video_in_external_interface_write_data),  
.ebab_video_in_external_interface_acknowledge (connected-to-ebab_video_in_external_interface_acknowledge), 
.ebab_video_in_external_interface_read_data   (connected-to-ebab_video_in_external_interface_read_data)  </pre>
  </li>
  <li>Copy/paste this group of signals into the <a href="../HPS_FPGA/master_peripheral/computer_module_video_input.txt"><em>Computer_system module</em></a> which is located in the top-level module.</li>
  <li> Substutute your own signal names for the connections, as you write the state machine required to read/write the Avalon bus.<br />
    See the VGA display bus_master example below for such a state machine.
  </li>
</ol>
<p><strong>-- External bus to Avalon Bridge</strong><br />
  Student generated modules will need to be Avalon bus-slaves when controlled by the HPS, but under some conditions will need to be bus-masters. For instance, building a module which writes directly to the VGA interface would require a bus-master ability. The first example uses the University Progam<span style="font-size: medium; font-style: normal; font-weight: normal;"> <a href="../External_Bus_to_Avalon_Bridge.pdf">External Bus to Avalon Bridge</a></span> (EBAB) module as a bus-master which addresses either the LEDs or the HEX display to display numbers set on the toggle switches, and with a write-enable using <span style="font-family: Consolas, 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', Monaco, 'Courier New', monospace; font-size: medium;">~KEY[0]</span>. The <a href="../HPS_FPGA/master_peripheral/SW_LED_1/hex_read.c">HPS C-code</a> reads and displays the SW and KEY peripherials. The <a href="../HPS_FPGA/master_peripheral/SW_LED_1/Qsys_switches_LEDs.PNG">Qsys layout</a> has just the HPS, parallel ports for the LEDs, HEX display, switches, and buttons, and the EBAB module. The LEDs and HEX display are hooked to the 
external-to-avalon
master. The SW and KEY are hooked to the HPS h2f_lw_axi_master. (<a href="../HPS_FPGA/master_peripheral/SW_LED_1/DE1_SoC_Computer.v">top-level</a>, <a href="../HPS_FPGA/master_peripheral/SW_LED_1/hex_decoder.v">hex decoder</a>, <a href="../HPS_FPGA/master_peripheral/SW_LED_1/DE1-SoC_avalon_master.zip">project ZIP</a>). This code ignores the Avalon ACK bit and does not read any data.
<p><strong>-- Controlling the bus-master from the HPS</strong><br />
  In the second example, the HPS uses a <a href="../HPS_FPGA/master_peripheral/HEX_LED_HPS_address/master_addr.c">keyboard command interface</a> to choose the HEX or LED device address which is used by the EBAB. The FPGA side has a small state machine which counts time and uses the EBAB to display the count on the HEX or LED devices. The state machine also handles the bus-write setup and waits for the Avalon bus ACK. The <a href="../HPS_FPGA/master_peripheral/HEX_LED_HPS_address/Qsys_addr_control.PNG">Qsys layout</a> converts the switch PIO into an output getting data from the HPS light-weight bus. This new output is used for the device address by the EBAB. (<a href="../HPS_FPGA/master_peripheral/HEX_LED_HPS_address/DE1_SoC_Computer.v">top-level</a>, <a href="../HPS_FPGA/master_peripheral/HEX_LED_HPS_address/DE1-SoC_avalon_master_addr_cntl.zip">project ZIP</a>). This example is a model of how a hardware computational unit might be controlled by the HPS and interact with other bus-attached peripherials. The bus transaction from EBAB to HEX display PIO takes two cycles (write, ACK). I tested up to 100 MHz state machine rate, for a bus rate of 50 million/sec. <br />
  -- 
The logical sequence is: A C-program outputs a bus address to the h2f_lw_axi_master address (of the ARM) which is mapped to a PIO unit on the Avalon bus. The PIO unit exports the address value to the FPGA fabric, which also contains the EBAB. The EBAB uses the address (from the PIO) to set its own write address back onto the Avalon bus.
<p><strong>-- Multiple bus-masters to one bus-slave</strong><br />
  The Qsys bus generator constructs arbitration hardware for various configurations of masters and slaves. I wanted to test the operation of multiple bus-masters talking to one bus-slave. The previous example was extended to have two EBAB units, one controlled as before with its bus address controlled by a<a href="../HPS_FPGA/master_peripheral/Two_masters/master_addr.c"> C program</a>. The other was set to always write to the HEX display. The phase of the write-clock was set up so that they write at different times. Each bus-master counts  at different rates. The counts are displayed on the HEX displays and for bus-master one, on the LEDs, when chosen. The <a href="../HPS_FPGA/master_peripheral/Two_masters/Qsys_layout.PNG">Qsys layout</a> shows that both the EBAB masters connect to the HEX display. (<a href="../HPS_FPGA/master_peripheral/Two_masters/DE1_SoC_Computer.v">top-level</a>, <a href="../HPS_FPGA/master_peripheral/Two_masters/DE1-SoC_avalon_two_master.zip">project ZIP</a>).
  <br />
  --
A modification of the <a href="../HPS_FPGA/master_peripheral/Two_masters/Fast_version/DE1_SoC_Computer.v">top-level module</a> changes the bus request rate to 3.1 MHz, uses the SW input to set the delay between bus write-requests, and puts the two write-requests and the two ACK bits on the GPIO_0 port for view on an oscilloscope. If the separation is zero <em>and</em> addresses are set to the same bus_slave, <em>then</em> one write-request is stretched to <a href="../HPS_FPGA/master_peripheral/Two_masters/Fast_version/two_write_enable_one_addr.bmp">two cycles</a> (top trace) while the bus is busy with the other. If two different bus-slaves are addressed by the two bus-masters, <em>or</em> the time between write-requests is  one cycle or more, <em>then</em> there is no collision and the write-requests are each <a href="../HPS_FPGA/master_peripheral/Two_masters/Fast_version/two_write_enable_two_addr.bmp">one state-machine cycle</a> long. Synchronization in the bus-master state machines depends on reading the ACK bits returned from the Avalon bus. Which write-request actually gets stretched, when they are on the same cycle, seems to be randomly determined by race-conditions.
<p><strong>-- VGA  display bus_master with HPS/FPGA mixed graphics source</strong><br />
  A bus-master to control video display is useful for many projects. Interfacing to the University video suite is challanging because the documentation is scattered or non-existant. The <a href="../HPS_FPGA/master_peripheral/EBAB_VGA/vga_EBAB.PNG">Qsys layout</a> shows the connections to the bus-master at the bottom. You can see in the Qsys layout that both SDRAM and on-chip RAM are used. Both are necessary, but I am not sure how they are related. The interface I finally came up with can write pixels at about 6.1 megapixels/sec, at 640x480 resolution.  I had to phase-lock the write cycle to the <span style="font-family: Consolas, 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', Monaco, 'Courier New', monospace">VGA_BLANK_N</span> signal to avoid confilct with the VGA read cycle. I am not sure why the <a href="../HPS_FPGA/master_peripheral/EBAB_VGA/media_video_master.c">HPS program</a> does not need to do that. The demo hardware writes a large blue rectangle a the top of the screen (as a background for text drawn by the HPS), then a slowly moving, 8-bit color map, then a diagonal line, and leaves a space at the bottom of the screen for a rectangle drawn by the HPS. The Avalon bus handles contention between the HPS and my bus-master so that graphics from the FPGA fabric can be merged with HPS graphics by simply writing the pixels. In this example, the text overlay is controlled only by the HPS. (<a href="../HPS_FPGA/master_peripheral/EBAB_VGA/DE1_SoC_Computer.v">top-level module</a>, <a href="../HPS_FPGA/master_peripheral/EBAB_VGA/DE1-SoC_video_bus_master.zip">project ZIP</a>, <a href="../HPS_FPGA/master_peripheral/EBAB_VGA/text_screen.jpg">test image</a>). There is a slight VGA sync artifact on this version. <br />
  -- 
  Changing one line of code eliminates the sync artifact, but lowers the write rate to 2.8 megapixels/sec. The condition for starting a write operation goes from<br />
  <span style="font-family: Consolas, 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', Monaco, 'Courier New', monospace">if (state==0 &amp;&amp; ~VGA_BLANK_N) begin</span><br />
  to<br />
  <span style="font-family: Consolas, 'Andale Mono', 'Lucida Console', 'Lucida Sans Typewriter', Monaco, 'Courier New', monospace">if (state==0 &amp;&amp; (~VGA_VS | ~VGA_HS)) begin</span><br />
making the start condition tighter and leaving a little slack before the next VGA read so that it does not contend with the second cycle of the write. The problem occurs because the blanking interval end is tested on the first write-cycle, but the write process takes two cycles, thus overlapping the first VGA read, whereas the vertical and horiztal sync pulses are narrower.<br />
-- If we could make the write condition less restricitve, but still shorter than the blanking pulse we could recover much of the write rate, but avoid the sync jitter artifact. By detecting the start of the vertical and horizontal sync pulses we can stretch the pulses to get the performance back up to over 6 megapixels/second. A revised<a href="../HPS_FPGA/master_peripheral/EBAB_VGA/Improved_top_level/DE1_SoC_Computer.v"> top-level module</a> does this with stable sync performance.
<p>-- <strong> VGA  display bus_master with FPGA graphics state machine source</strong><br />
  In this example, the display bus-master gets pixel color information from a true dual-port, M10K block, RAM based state machine. The graphics are trivial vertical lines, with x position chosen by the DE1-SoC switches and the color by two of the push buttons. Pushing button zero loads the switch and button information to the drawing state machine which populates M10K RAM with the 2-bit pixel colors for the line. The bus-master state machine moves all the pixels in the M10K RAM to VGA display memory by converting the two-bit M10K state to 8-bit color and putting the data on the Avalon bus. Since the M10K RAM is dual ported, the line-writing state machine and bus_master state machine can access memory at the same time. In general for high performance, you would not want to draw every pixel every time like this example does. (<a href="../DE1_soc_computer/VGA_state_machine/DE1_SoC_Computer.v">top-level module</a>, <a href="../DE1_soc_computer/VGA_state_machine/DE1-SoC_video_only_local_memory.zip">ZIP</a>)
<p><strong>-- VGA display of video input using a bus_master to copy input image</strong><br />
  <a href="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/20170223_160811.jpg"><img src="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/20170223_160811_small.jpg" width="275" height="200" alt="" align="left"/></a>  
  A modified Qsys layout (see also <a href="univ_pgm_computer.index.html">University Computer page</a>, <em>Video input from NTSC to on-chip-memory, then to VGA using HPS</em> ) adds a bus_master which can read from the <a href="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/Qsys_EBAB_SRAM_2.png">on-chip SRAM</a> used to store the<a href="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/Qsys_vid_in_SRAM_1.png"> video input</a> and write to the <a href="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/Qsys_EBAB_SDRAM.png">VGA buffer SDRAM</a> which is also <a href="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/Qsys_vga_SDRAM.png">connected</a> to the VGA controller. The pixel copy state machine runs at 50 MHz, so a <a href="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/Qsys_clock_bridge.PNG">clock bridge</a> was added to drive the the EBAB module. Video input is enabled by SW[1] up, Copy from the input buffer to the VGA display is enabled by SW[0] (may need to press KEY[0] to reset), and a HPS progam must be run to set up the video input and demonstrate sumultaneous access to VGA from the HPS and custom bus_master. The VGA buffer bus traffic, plus video-input to VGA bus traffic, plus HPS to VGA bus traffic can exceed the bus bandwidth. The writing rate of the HPS program and the video-input to VGA are throttled. This version of the code has the screen position of the input image hard-coded, but the buffer can be resized and moved to other screen locations. (<a href="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/DE1_SoC_Computer.v">top-level</a>, <a href="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/computer_15_640_video_mod_EBAB.zip">ZIP</a>, <a href="../DE1_soc_computer/Video_input/EBAB_vid_in_to_vga/enable_video_input_3.c">HPS code</a>). <br clear="left"/>
<p>-- <strong>VGA display using a bus_master as a GPU for the HPS.</strong> <strong>Display from SDRAM</strong>.<br />
  A simple GPU was written that only writes rectangles. It takes corners (x1,y1 and x2,y2) and colors from the HPS in SRAM scratchpad memory and displays them into SDRAM-buffered VGA. The SDRAM is therefore shared between the HPS, the GPU bus_master, and the VGA controller in Qsys. The SRAM scratchpad is shared between the HPS and the GPU bus_master. The HPS is attached to SRAM scratchpad using Qsys, but the bus_master is attached in the FPGA fabric, not in Qsys. The bus_master state machine reads five values from the scratchpad, then drops into a loop until both x,y exceed their limits. The loops includes a write operation to the bus (4 cycles), plus a delay to allow the VGA controller to access SDRAM. With a 50 MHz state clock, eight wait states are required in the delay to avoid video artifacts. The number of wait-states can be set using the upper four switches from 0 to 15. This results in about 4 pixels/microsceond write rate, about the same as the HPS. The first HPS code queries the command line for five numbers, where x1&lt;x2, y1&lt;y2, and color 0-255, then draws on the left side in hardware and on the right side from the HPS. The second HPS code draws rectangles as fast as possible to test for stability. Again, the left and right sides of the <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sdram_vga/20170410_151417.jpg">screen</a> are written respectively from hardware and from the HPS, and should match (<a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sdram_vga/rectangle_gpu_1.c">HPS code1</a>, <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sdram_vga/rectangle_gpu_2.c">HPS code2</a>, <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sdram_vga/DE1_SoC_Computer.v">top-level</a>, <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sdram_vga/computer_15_640_video_sram_master.zip">ZIP</a>)
  <br />
<p>-- GPU with <strong>FAST</strong> display from <strong>SRAM</strong>.<br />
The write rate of the above SDRAM-buffered VGA is low, so I rewrote the system (<a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/Video_from_sram.PNG">Qsys layout</a>) to use <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/Qsys_display_system.PNG">dual-port SRAM for the VGA buffer</a>. One port (s2) is connected through Qsys to the VGA controller and HPS, as usual. The other port (s1) is exported to the FPGA fabric, and connected directly to the GPU state machine in Verilog. The <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/Qsys_display_system.PNG">clock bridge shown</a> syncs the the SRAM slave port to the GPU state machine. The logic to control the GPU state machine from the HPS is unchanged from above. Direct connection of display memory to the GPU state machine results in a write-rate of 48 pixels/microsecond. To get the high rate, the GPU state machine was rewritten to pipeline writes to the VGA display SRAM. To minimize on-chip memory use, the display mode was set to 8-bit color and changed from x/y addressing to sequential addressing (<a href="../Video_core.pdf">video core</a> section 2.1, <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/PACKEDvsXY.txt">code snippet</a>), saving 30% of SRAM. To make the mode change, the <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/pixel_dialog.png">VGA_pixel_DMA module dialog box</a> in the VGA subsystem needs to be modified. The HPS code is also changed to reflect the modified display mode.  The <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/screen.jpg">left and right sides of the screen</a> are written respectively from hardware and from the HPS, and should match. The times at the top of the screen are the writing times of the last polygon for hardware and software respectively. (<a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/rectangle_gpu_3.c">HPS code</a>, <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/DE1_SoC_Computer.v">top-level</a>, <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/video_sram_master_sram_vga.zip">ZIP</a>). A slightly improved version of the <a href="../HPS_FPGA/master_peripheral/rectangle_gpu_sram_vga/rectangle_gpu_5F3a.c">HPS code</a> does parameter validation before setting up the GPU draw operation.
<p><strong>-- Audio output bus_master</strong><br />
  This bus_master state machine reads the FIFO status of the <a href="../Audio_core.pdf">University Program audio interface</a>, and if there is sufficient space in the FIFO, computes a new DDS sinewave sample and inserts it into the left and right audio channel FIFOs. The <a href="../HPS_FPGA/master_peripheral/EBAB_Audio/qsys_layout.PNG">Qsys layout</a> shows the relatively simple connections. The audio bus_master <em>avalon_master</em> is connected to the audio subsystem <em>avalon_slave</em> input. The design leaves the HPS interface in place, but contention between the two bus-masters for audio channels means that you can use one or the other (but see below for sharing the audio left/right channels). The state machine sets up the FIFO status read, then waits for the ACK. IF there is space in the FIFO, a new DDS sample is computed and written to the left channel, then waits for the ACK.
The right channel is then written. Both channels must be written for the audio interface to work. Waiting for space in the FIFO effectively phase-locks the state machine to the audio-rate clock for sound systhesis (<a href="../HPS_FPGA/master_peripheral/EBAB_Audio/DE1_SoC_Computer.v">top_level_module</a>, <a href="../HPS_FPGA/master_peripheral/EBAB_Audio/DE1-SoC_Computer_15_audio_only.zip">project ZIP</a>).
<br />
-- If the audio bus-master hardware only checks that status of the left channel FIFO and only loads the left channel FIFO, and the HPS only 
checks that status of the right channel FIFO and only loads the right channel FIFO, then both can write to the audio at the same time. Since nothing is played by the audio interface unless there is data for each channel, the shorter duration channel determines play time. In this example, a WAV file is read by Matlab and samples sent by UDP to the HPS, which runs a thread to watch the UDP connection, and another thread to load the right channel. The hardware audio bus-master loads the left channel FIFO, then stalls until the HPS thread starts filling the right channel FIFO. (<a href="../HPS_FPGA/master_peripheral/EBAB_Audio/EBAB_and_HPS/UDP_audio_thread.m">matlab program</a>, <a href="../HPS_FPGA/master_peripheral/EBAB_Audio/EBAB_and_HPS/thread_udp_right_channel.c">HPS program</a>, <a href="../HPS_FPGA/master_peripheral/EBAB_Audio/EBAB_and_HPS/DE1_SoC_Computer.v">top-level module</a>). The result is that the hardware plays a tone on the left channel during the time that the HPS program loads the right channel. Note that the hardware bus-master checks the top eight bits of the FIFO status word, while the HPS program checks the next eight bits (see section 4.1 of the <a href="../Audio_core.pdf">Audio Core manual</a>). The LEDR display is connected to the left channel FIFO status. When both sources are filling the FIFOs, you can see the contention by the variability of the FIFO depth, but actual audio play not affected.
<hr />
<p>References:</p>
<p><a href="../index.html">DE1-SOC</a> literature list</p>
<p><a href="../../../eceprojectsland/STUDENTPROJ/2014to2015/ayk33/Independent_Study.pdf">Using the DE1-SOC FPGA</a> by Ahmed Kamel </p>
<p><a href="../../../eceprojectsland/STUDENTPROJ/2014to2015/ayk33/index.html">Stereoscopic Depth on an FPGA via OpenCL</a> by Ahmed Kamel and Aashish Agarwal</p>
<p><a href="../../../eceprojectsland/STUDENTPROJ/2015to2016/sm893_mkp53/Final%20Report%20ECE%204999.pdf">Running Linux on DE1-SOC</a> by MANISH PATEL and SYED TAHMID MAHBUB</p>
<p><a href="../../FinalProjects/s2015/spp66_aa2264_ayk33/spp66_aa2264_ayk33/spp66_aa2264_ayk33/FPGA_ARM.html">OpenCL on DE1-SOC</a> Sahil P Potnis (<a href="mailto:spp66@cornell.edu">spp66@cornell.edu)</a> Aashish Agarwal (<a href="mailto:aa2264@cornell.edu">aa2264@cornell.edu</a>) Ahmed Kamel (<a href="mailto:ayk33@cornell.edu">ayk33@cornell.edu</a>)</p>
<p><a href="../../../../../../ftp@ftp.altera.com/up/pub/Altera_Material/15.1/University_Program_IP_Cores/Audio_Video/Audio.pdf">Audio Core</a> (Qsys University Program 15.1) <a href="../Audio_core.pdf">local copy</a></p>
<p><a href="../../../../../../ftp@ftp.altera.com/up/pub/Altera_Material/15.1/University_Program_IP_Cores/Audio_Video/Video.pdf">Video Core</a> (Qsys University Program 15.1) <a href="../Video_core.pdf">local copy</a></p>
<p>Analog input Core  (Qsys University Program 15.1) <a href="../ADC_Controller.pdf">local copy</a></p>
<p><a href="../External_Bus_to_Avalon_Bridge.pdf">External to Avalon Bus Master</a> (<em>external</em> here means<em> <strong>in the FPGA</strong></em>, but not in the Qsys bus structure)</p>
<p><a href="../Avalon_to_External_Bus_Bridge.pdf">Avalon to External Bus Slave</a> (<em>external</em> here means<em> <strong>in the FPGA</strong></em>, but not in the Qsys bus structure)</p>
<hr />
<p>Copyright Cornell University 
  <!-- #BeginDate format:Am1 -->February 28, 2018<!-- #EndDate -->
</p>
<p>&nbsp;</p>
</body>
</html>
