<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>DSP</title>
<style type="text/css">
<!--
.style2 {color: #FF0000}
-->
</style>
</head>

<body>
<h2 align="center">DSP examples <br>
  ECE 576 Cornell University
</h2>
<p>Most of the projects are audio, although one generates modulated RF. <br>
<strong>List of projects included on this page:</strong></p>
<ol>
  <li>IIR Audio filters (2, 4, and 6-pole, 47 kHz sample rate ):
    <ol>
      <li>18-bit, fixed point FSM </li>
      <li>27-bit, fixed point FSM </li>
      <li>18-bit, fixed point using a cpu</li>
      <li>18-bit, fixed point using parallel pipeline </li>
      <li>18-bit floating point using Second Order Sections (SOS) </li>
      <li>(To do: second order sections, FIR, multiple filters in one state machine ) </li>
    </ol>
  </li>
  <li>16-bit fixed point CIC (cascaded integrator-comb)</li>
  <li>Soft Radio Transmitters: AM, FM </li>
  <li>Physical (Karplus-Strong) String synthesis </li>
  <li>DDS, Noise and FM sound synthesis</li>
  <li>Adaptive noise cancellation </li>
  <li>Audio CODEC documentation</li>
</ol>
<hr>
<ol>
  <li><strong>Audio filter implementations</strong><br>
      All of these implementation use a  multiply-and-accumulate (MAC) scheme to  compute each of the terms on the right side of the following equation, then divides by <code>a(1)</code>, if necessary. Some of the implementations are serial, some are parallel. Some are fixed point, some floating. <br>
      <pre>a(1)*y(n) = b(1)*x(n) + b(2)*x(n-1) + ... + b(nb+1)*x(n-nb) 
                      - a(2)*y(n-1) - ... - a(na+1)*y(n-na)<br>
If a(1) is not equal to 1, you must divide the right side by a(1). </pre>
The actual filter form implemented was the <em>Direct Form Type I transposed</em> similar to what Matlab uses for its <code>filter</code> function. This means that the Matlab filter design funcitons (which yield the a's and b's) can be used to design filters. Input is from the audio codec and output is back to the audio codec. <br>
<br>
There are a set of modules which are needed for all of the test programs below which interface to the audio codec. They are: <a href="AudioFilter_oct2009/AudioFilter_oct2009/cpuclockPLL.v">cpuclockPLL.v</a>, <a href="AudioFilter_oct2009/AudioFilter_oct2009/I2C_AV_Config.v">I2C_AV_Config.v</a>, <a href="AudioFilter_oct2009/AudioFilter_oct2009/I2C_Controller.v">I2C_Controller.v</a>, <a href="AudioFilter_oct2009/AudioFilter_oct2009/Reset_Delay.v">Reset_Delay.v</a>, <a href="AudioFilter_oct2009/AudioFilter_oct2009/AUDIO_DAC_ADC.v">AUDIO_DAC_ADC.v</a> and <a href="AudioFilter_oct2009/AudioFilter_oct2009/VGA_Audio_PLL.v">VGA_Audio_PLL.v</a>. Each of the filter implementations has one top level module which needs to be incorporated into the project (using the menu item: project&gt;Add/Remove files in project). The project with all top-level modules and interfaces is <a href="AudioFilter_oct2009/AudioFilter_oct2009.zip">zipped here</a> (QuartusII version 8.1). All of these filters receive input from the audio <code>line-in</code> (blue phone jack) and send output to audio <code>line-out </code>(green phone jack). The project archive  (QuartusII version 10.1) using 18-bit fixed point filters (and a slightly different audio out register structure) is <a href="AudioFilter_oct2009/Audio_Filter_18_bit.qar">here</a>.<br>
<br>
      <strong>General second, fourth and sixth order IIR (18-bit fixed point) </strong>. <br>
  The first implementation <a href="AudioFilter_oct2009/AudioFilter_oct2009/Audio_Filter_18bit_fixed.v">top-level module</a> has modules  for 2, 4, and 6th-order IIR audio filters synched to run once/audio sample (about 47 KHz).  Each filter runs in parallel with all the other filters and each filter uses one 18-bit multiplier, so that you could implement up to about 35 filters. The filters use 18-bit, 2's complement notation with 16 bits of fraction for both the signal and the coefficients. This means that all filter coefficients have to be scaled to the range<code> -1&lt;coefficient&lt;1</code>. The matlab code to do the scaling and conversion to hex constants will produce estimates of the scaled constants which you must check for being in range.<br>
  <br>
  A matlab program to form the Verilog to specify the filter is at the end of the Verilog file as a comment. Typical Verilog filter code generated by the Matlab program is shown below. You must rename the module, and substitute in appropriate input and output variable names. The matlab program computes the a and b values, scales them to avoid overflow, and converts them to hex. The matlab program also plots the exact filter solution as well as the scaled 16-bit approximation.  Always check the approximation to verify filter quality. The book <em>Digital Signal Processing and the microcontrolle</em>r was very useful for this code (see reference below).  <br>
  <br>
    An example of the generation of filters by creating the filter Verilog code in Matlab. The normalized filter cutoffs  (<code>frequency/(Fs/2)</code>) are <code> [0.1 0.2]</code>, for a 4th order filter, and scaled by <code>&gt;&gt;&gt;2</code>. Always check the approximation to verify filter quality. The plot below shows the result of coefficient truncation error on filter response. <br>
    <pre>//Filter: cutoff=0.100000 
//Filter: cutoff=0.200000 
IIR4 filter( 
     .audio_out (your_out), 
     .audio_in (your_in), 
     .scale (3'd2), 
     .b1 (18'h149), 
     .b2 (18'h0), 
     .b3 (18'h3FD6E), 
     .b4 (18'h0), 
     .b5 (18'h149), 
     .a2 (18'hCD98), 
     .a3 (18'h2F54E), 
     .a4 (18'hA42E), 
     .a5 (18'h3D6F5), 
     .state_clk(AUD_CTRL_CLK), 
     .lr_clk(AUD_DACLRCK), 
     .reset(reset) 
) ; //end filter </pre>
    <br>
    <img src="AudioFilter/ExactApprox4th.png" width="502" height="308"><br>
    <br>
    <strong>General second, fourth and sixth order  IIR Filter  (27-bit fixed point) .</strong><br>
    This implementation extends the precision of the filters to allow accurate, lower bandwidth filters. As before the code modularizes the IIR filters and simplifies the generation of filters by creating the filter Verilog code in Matlab. The current version of the <a href="AudioFilter_oct2009/AudioFilter_oct2009/Audio_filter_27bit_fixed.v">top-level module</a> has modules for 2, 4, and 6th-order IIRs and a modified <code>signed_mult</code> routine. The matlab program is at the end of the Verilog file as a comment.  The matlab program computes the a and b values, scales them to avoid overflow, and converts them to hex. As in the last example, you must rename the module, and substitute in appropriate input and output variable names. The matlab program also plots the exact filter solution as well as the scaled 24-bit approximation. Always check the approximation to verify filter quality. Note that each filter uses 7 multipliers, so the maximum number of filters is 10. You could use these more expensive filters for narrow bandwidth fiters, which require more numerical accuracy, and 18-bit filters for higher bandwidth filters. A fairly narrow band filter (<code>[0.1 0.13]</code> at 47kHz sampling rate), six-pole filter is shown below. <br>
    <img src="AudioFilter27bit/NarrowBand.png" width="560" height="420"><br>
    <br>
    <strong>IIR filters using a simple CPU</strong> <strong>with <a href="../../../../../instruct1.cit.cornell.edu/courses/ece576/DDA/index.htm">fixed point (2:16) multiplier</a></strong> <br>
  It is often handy to be able to write a program to filter, rather then generate a state machine. A small cpu (Hamblen chapter 9) was extended to act as a simple DSP unit by extending the data word length ot 18-bits, and adding a 2:16 multiply instruction. I wrote an <a href="AudioFilter/Filter18bitCPU/TinyASM18bit.m">assembler</a> for the cpu and a <a href="AudioFilter/Filter18bitCPU/ParameterFormatter.m">preprocessor</a> which takes filter specification input and generates a table of required coefficients in a format suitable for pasting into the assembler code as the <em>data section</em>. Note that the <code>'a'</code> filter coefficients are negated in the preprocessor so that only additions are necessary in the assembler code. Note also that the dynamic range of the filter constants is<code> +/-2</code>, so scaling is necessary <em>and must be specified by the user of the preprocessor (see examples above and the <a href="../../../../../instruct1.cit.cornell.edu/courses/ece576/DDA/index.htm">DDA page</a>!</em> A fourth-order filter assembler example is <a href="AudioFilter/Filter18bitCPU/Test18bitFilter.asm">here</a>. The mif file resulting from the assembler is <a href="AudioFilter/Filter18bitCPU/Test18bitFilter.mif">here</a>, and has to be referenced near the end of the top-level module. The <a href="AudioFilter_oct2009/AudioFilter_oct2009/Audio_filter_fixed_CPU.v">top-level module</a> builds three cpus and connects two to the audio i/o.   The top-level module resets the cpu on each left-right (stereo) clock transition (once per audio sample). The filter assembler source <em>data sections</em> are all that is different between <a href="AudioFilter/Filter18bitCPU/Test18bitFilter.asm">cpu1</a>, <a href="AudioFilter/Filter18bitCPU/Test18bitFilter2.asm">cpu2</a> and <a href="AudioFilter/Filter18bitCPU/Test18bitFilter3.asm">cpu3</a>. The resulting three mif files (<a href="AudioFilter_oct2009/AudioFilter_oct2009/Test18bitFilter.mif">cpu1</a>, <a href="AudioFilter_oct2009/AudioFilter_oct2009/Test18bitFilter2.mif">cpu2</a>, <a href="AudioFilter_oct2009/AudioFilter_oct2009/Test18bitFilter3.mif">cpu3</a>) are separately loaded into the respective cpu's M4K blocks. Note that the two cpu clocks are synced to CLOCK_50 (but the cpu PLL clocks them at 100 MHz.), while the cpu reset lines are synced to the audio control clock. Each 4-pole IIR filter takes 53 instructions to execute. Instructions are either 3 cycles or 5 cycles (for store). The number of cycles to execute each program is about 200 cycles, or two microseconds at 100 MHz. At a 48 KHz audio sample rate, about 10 four-pole filters could be run on each cpu, if there were enough memory for code and coefficients. One M4K block allows only about 3 four-pole filters to run. <br>
  <br>
  The assembler code does not have a loop, except for a spin-halt at the end, because execution starts at reset for each audio sample. The cpu ISA is:<br>
  <pre>instruction			effect
ADD addr        accum &lt;= accum + Mem(addr)		
STORE addr      Mem(addr) &lt;= accum	
LOAD addr       accum &lt;= Mem(addr)	
JMP addr        PC &lt;= addr	
JNEG addr       PC &lt;= (accum[17])? addr: PC
OUT addr        output(addr) &lt;= accum
IN addr         accum &lt;= input(addr)
MULT addr       accum &lt;= accum * Mem(addr) (signed 2:16 fraction)
SHL addr        accum &lt;= accum &lt;&lt; Mem(addr) (shift of 0 to 7 bits)
--single 18-bit accumulator
--addr is 12-bits</pre>
  <br>
  <strong>IIR filters using a parallel, pipelined design<br>
    </strong>This <a href="AudioFilter_oct2009/AudioFilter_oct2009/Audio_Filter_18bit_parallel.v">top-level module</a> is closely related to the canonical, direct form II, for an IIR digital filter (Grover and Deller, page 254, figure 6-27). The figure below is from matlab documentation.<br>
    <img src="AudioFilterParallel/CanonicalIIR.gif" width="441" height="100"> <br>
  The filters are resource intensive compared to the state machine filters above, but they are very fast because they are pipelined and all possible MACs happen at the same time.
  <br>
  <br>
  <strong>IIR filters using 18-bit floating point and Second-Order Sections (SOS)<br>
  </strong>SOS filters have the advantage (over straight multipole filters) of smaller dynamic range on coefficients, so the numerical stability is better. SOS filters are also more straight forward to do with floating point.
  <!--
  <li><strong>Small 18-bit CPU for floating point</strong> <br>
    The small 16-bit CPU described in Hamblen, chapter 9, was converted to 18 bits, and the assembler modified to support 18-bit words. The opcode field is dropped to 6 bits, and the address/immediate/output field increased to 12 bits. The verilog is <a href="../DE2/TinyCPU/18bitCPU/DE2_uP3v3.v">here</a>. The QuartusII project archive is <a href="../DE2/TinyCPU/18bitCPU/DE2_TOP_18bit_archive.qar">here</a>. The assembler is a Matlab <a href="../DE2/TinyCPU/18bitCPU/TinyASM18bit.m">program</a> which takes an <a href="../DE2/TinyCPU/18bitCPU/TestPgm18bit.asm">asm</a> file and produces a <a href="../DE2/TinyCPU/18bitCPU/TestPgm18bit.mif">mif</a> file. The mif file name is referenced in the verilog near the end of the file. In the mif file, the first two digits are the opcode, the last three are the address. This cpu version has no actual FP hardware in it yet, but the modules described above can be added easily. 
-->
The downside is a few more state variables and a few more multiplies for each filter. A matlab <a href="../FloatingPoint/SOSfilters/AudioFilterParamsGenFP.m">program</a> and <a href="../FloatingPoint/SOSfilters/FPconvertFun.m">function</a> convert filter specifications to Verilog with 18-bit floating point. The <a href="AudioFilter_oct2009/AudioFilter_oct2009/Audio_Filter_18bit_float.v">top-level module</a> defines filters of order 2, 4 and 6. <strong><br>  
<br>
  </strong>There is more information on floating point on the <a href="../FloatingPoint/index.html">floating point page</a>. Examples 3 and 4 on that page implement filters using floating point arithmetic. Example 4 is more stable becuase it uses <a href="../../../../../en.wikipedia.org/wiki/Digital_biquad_filter">second-order-sections</a> (digital <i>biquadratic</i> sections) for the filters.
  <hr>
  </li>
  <li><strong>16-bit fixed point CIC (cascaded integrator-comb)</strong> <strong>filters</strong><br>
    CIC filters are used when you need to low-pass filter <em>and</em> downsample at the same time. An example might be when you are demodulating an radio-frequency signal with a sample frequency of 50 MHz, but with a modulating signal in the audio range, which only needs a sample frequency of 48 KHz. See also <a href="../../../../../www.mikrocontroller.net/attachment/51932/cic2.pdf">CIC
    Filter Introduction by Matthew P. Donadio</a> and <a href="../../../../../www.design-reuse.com/articles/10028/understanding-cascaded-integrator-comb-filters.html">Understanding
  CIC filters</a>. <br>
  <br>
  <strong>CIC with N=1,2, and 4 and M=1.</strong><br>
  This example has first, second, and fourth order CIC filters. The <a href="CIC_filter_2010/CIC_N1_2_4_16bit_fixed.v">top-level module</a> should be used with the codec code zipped at the top of the page. A 108*2<sup>SW[3:0]</sup> Hz sine wave sampled at 27 MHz is downsampled to 48 KHz. Both sine waves are output to the audio DAC. This simple code will <strong>not work</strong> at a  clock frequency higher than about 27 MHz because the long adders (40 to 60 bits) cannot complete a carry in much less time. <br>
    <hr>
  </li>
  <li><strong>Soft Radio Transmitters <br>
        <span class="style2">Note that it is illegal in the USA to operate an unlicensed transmitter on the AM or FM band (except under very limited conditions) or to cause radio interference in any way to someone else's reception. </span> <span class="style2">The following transmitter designs should be considered only as examples of modulation techniques and not used for any purpose. </span><br>
        <br>
    AM transmitter: <br>
    </strong>Since the VGA DAC can sample above 50 MSamples/sec, it is possible to directly generate an amplitude-modulated radio signal in the standard AM band (530 KHz to 1700 KHz). The <a href="TransmitterAM/AM_xmit_audio_input.v">top-level module</a> uses direct digital synthesis (DDS) to generate a 1.0 MHz sine wave for a carrier, then multiplies the carrier by an audio signal consisting of either a 400 Hz DDS unit or audio from the audio codec module described at the top of the page. The design implements:<br>
    <br>
    <code>y(t) = (C + a(t))*sin(2*&pi;*F*t)</code>,<br>
    <br>
    where F=1.0 MHz, a(t) is the audio signal, and y(t) is the transmitted waveform. The audio signal originates in the audio codec ADC described in example 5 above. The audio signal has to be manipulated slightly to change the format from signed, 2's complement (produed by the audio codec ADC) to offset binary (required for the VGA DAC). The transmitted signal can be received by placing an AM radio within a few inches of the VGA connector. Do not connect an antenna to the VGA connector. 
    <p> <strong>FM Transmitter:</strong> <br>
      The FPGA and DAC are not fast enough to generate a 100 MHz sine wave, but the 19th harmonic of a 4.5 MHz square wave falls in the FM band. Note that this design can cause strong radio interference at many frequencies and should never be used to actually transmit anything. The <a href="TransmitterFM/DE2_Default.v">top-level module</a> uses direct digital synthesis (DDS) to generate a 4.5 MHz FM modulated square wave using an audio signal consisting of either a 400 Hz DDS unit or audio from the <a href="TransmitterAM/AUDIO_DAC_ADC.v">audio codec module </a> for modulation. The design implements:<br>
      <br>
      <code>y(t) = 0&lt;sine((2*&pi;*F+&delta;f*a(t))*t)</code>,<br>
      <br>
      where F=4.5 MHz, a(t) is the audio signal, <code>&delta;f</code> is the conversion factor from audio input amplitude to frequency range, and y(t) is the transmitted, variable frequency, squarewave. The audio signal originates in the audio codec ADC described in example 5 above. The audio signal has to be manipulated slightly to change the format from signed, 2's complement (produed by the audio codec ADC) to offset binary. The verilog code below implements the DDS for carrier and audio tone generation, and modifies the DDS increment to FM modulate the signal. The <code>&delta;f</code> scaling factor is the left-shift of 15 bits. SW0 is used to select between two tones. SW1 is used to select tone or ADC audio input. 
      
    <pre>always @ (posedge CLOCK_50) begin
		//generate 4.5 Mhz square wave carrier with FM modulation
		DDS_accum <= DDS_accum + 32'h16FC7BBC + 
				((SW[1])?  //Choose: sine wave/audio input
				(mod_out&lt;&lt;15) : 
				(256+((modulation[15]==0)? modulation[15:7]+256 : modulation[15:7]-256))&lt;&lt;15) ;
		// generate 400/800 Hz
		DDS_accum_mod = DDS_accum_mod + ((SW[0])? 32'hF5E7 : 32'h85E7) ;
	end
	//hook up the ROM table for carrier
	sqwave sqTable(CLOCK_50, DDS_accum[31:24], sq_out);
	//hook up the ROM table for 400 Hz modulation
	sync_rom modTable(CLOCK_50, DDS_accum_mod[31:24], mod_out);
	//use the VGA DAC for an FM modulated RF signal 
	assign VGA_R = sq_out;
	assign VGA_SYNC = 1 ;
	assign VGA_BLANK = 1 ;
	assign VGA_CLK = CLOCK_50 ; </pre>
    The transmitted signal can be received by placing an FM radio within a few inches of the VGA connector. Do not connect an antenna to the VGA connector. The whole <a href="TransmitterFM/Transmitter_Sound.zip">project is zipped here</a>. </li>
  <hr>
  <br>
  <li> <strong>Physical Audio Synthesis</strong><br>
    The <a href="../../../../../en.wikipedia.org/wiki/Karplus-Strong_string_synthesis">Karplus-Strong algorithm</a> is a scheme for synthesizing the sound of a plucked string using <a href="../../../../../ccrma.stanford.edu/~jos/pmupd/default.htm">physical synthesis</a> techniques. The basic algorithm is simple enough to run in realtime on a microcontroller (see the <a href="../../../../../instruct1.cit.cornell.edu/courses/ee476/Math/avrDSP.htm">microcontroller DSP page</a>), but various extensions can be added which eat up processing. I implemented the basic algorithm in Verilog with the idea that multiple strings can be synthesized on the same FPGA. The scheme uses M4K block memory, hardware multipilers, and the audio codec. A state machine runs through five states once per audio sample (48KHz) using the left/right channel clock for sync. When a button is pushed, a burst of random numbers is injected into the model string to simulate a pluck. An example tuned to approximately 110 Hz (2 octaves below 440 A) is <a href="KarplusStrong/KS110hz.wav">here</a>. A scope screen shot below shows the waveform.  A simple user interface<a href="KarplusStrong/KSsetFreq.v"></a> allows you to chose the string frequency using the swithces. The interface is not very handy to use because the frequency and switch setting are inversely related. String damping is set by a gain factor which can take on values between about 0.47 and 0.50 (minimum damping). The default value used here is 0.495 (<code>18'h0_7EB8</code> in 18-bit 2's complement)), which is appropriate for lower frequency strings, but too low for higher frequencies. <br>
    <img src="KarplusStrong/KS110HzScope.jpg" width="450" height="317"><br>
    <br>
     I added a low pass filter to the string pluck function. The cutoff is set very coarsely by switches [17:15]. All three switches in the up-position is minimum bandwidth, all switches in the down-position is unfiltered white noise. Compare <a href="KarplusStrong/KSunfiltered.wav">unfiltered</a> and <a href="KarplusStrong/KSfiltered.wav">heavily filtered</a> for the same fundamental frequency. Switches [11:0] still set the period of the simulated string so that string <code>frequency=48000/SW[11:0].</code> The <a href="KarplusStrong/KSsetFreqLopass.v">top module</a> and the <a href="KarplusStrong/AUDIO_DAC_ADCsimpilfied.v">AUDIO_DAC_ADC</a> module were modified. The AUDIO_DAC_ADC module is considerably simplified by eliminating all inputs except audio generated by the top level module. The whole project is <a href="KarplusStrong/Karplus_strong_2.qar">archived here</a>. <br>
    <hr>
  </li>
  <li>DDS and FM synthesis<br>
    DDS running at audio clock rate is connected to the audio codec DAC channels. <a href="DDS_Example/sine_wave.v">Code</a>. <a href="DDS_Example/Simple_Sine_Wave.qar">Quartus Archive</a>.  The output frequency is set as<br>
    <code>F = (SW*(2^14))*(audio clock rate)/(2^32) = SW*(audio clock rate)*(2^-18) =  SW*46000*(2^-18)</code><br>
The 2^14 is an scale factor to put the frequency into the audio range. The 2^32 results from using a 32 bit accumulator. <br>
A <a href="DDS_Example/sine_wave_and_noise.v">second design</a> adds low pass filtered white noise to one channel. <code>SW[0]</code> DOWN outputs noise and <code>SW[0]</code> UP outputs quadrature sine wave.<br>
A <a href="DDS_Example/sine_wave_module.v">third design</a> modularizes the DDS (and adds phase control) and noise generators (and enables gain/cutoff setting on noise). <br>
A <a href="DDS_Example/sine_wave_decay.v">fourth design</a> combines two DDS modules, with added exponential atttack/decay, to form an FM audio synth channel. <br>
    <hr>
  </li>
  <li><strong>Adaptive Noise Cancellation</strong><br>
    Noise cancellation techniques attempt to dynamically find a filter which will remove a source of noise given two inputs: (1) A noise-contaminated input and (2) a noise reference. The two inputs might be (1) a 60 Hz contaminated electrophysiolgical recording and (2) input from the 60 Hz power line for reference. The filter needs to change in realtime because the nominal 60 Hz line actually varies by a few tenths of a cycle/sec over a period of a few minutes, so that a fixed, narrow-band notch filter will fail. The <a href="../../../../../en.wikipedia.org/wiki/Least_mean_squares_filter">least-mean-squares</a> (<a href="../../../../../cwww.ee.nctu.edu.tw/course/asp/ASP04.pdf">LMS</a>) algorithm (see De Stefano reference below) can easily be implemented at audio rate on an FPGA. <br>
    <br>
    <strong>Two tap 60 Hz noise reduction</strong> <br>
    The algorthms used here were tested first in Matlab. The first algorithm I implemented was from Ramos (see below), but modified for 60 Hz. The <a href="NoiseCancel/Noise60hzAP.m">matlab program</a> generates some fake action potentials and 60 Hz noise, adds them, then adaptive filters them by adjusting the phase and amplitude of a signal derived from the reference 60 Hz signal. The image below shows two panels. The top panel is the AP signal (spikes) contaminated by 60 Hz noise of the same amplitude. The bottom panel shows two traces. The red trace is the noise free input and the blue trace is the adaptively filtered output. You can see that the 60 Hz noise dies away over a few tenths of a second. <br>
    <img src="NoiseCancel/APwith60Hz.png" width="757" height="511"> <br>
    The Verilog version of this algorithm (summarized in the image below) is contained in the <a href="NoiseCancel/Noise60hz1.v">top-level module</a>. The delay is implemented as a 200 entry circular buffer (at 48KHz audio sample rate, one cycle of 60 Hz is 800 sample times, so 200 samples is a phase shift of &pi;/2). The <em>spurious coupling</em> lightning bolt refers to undesirable and unplanned electrostatic and magnetic interactions between equipment and the biological system resulting in 60 Hz noise in the recorded data. Some care is required to properly sequence the M4K block memory as a ring buffer. The state machine runs on the positive edge of the clock, the memory is updated on the negative edge. In addition, the write-address and write-data have to be set up before the write-enable is activated. The value of &mu; was set at a constant 2<sup>-10</sup> implemented by a right-shift.<br>
    <br>
    <img src="NoiseCancel/LMS1flow.png" width="583" height="302"><br>
    <br>
    The <a href="NoiseCancel/AUDIO_DAC_ADC.v"><code>Audio_DAC.ADC</code></a> input/output was again modified and simplified. A <a href="NoiseCancel/RefSigAudio.m">matlab program</a> generated the reference noise and simulated biological signal. The whole project is <a href="NoiseCancel/NoiseCancel1.zip">zipped here</a>. Three scope images show the whole adaption sequence, the first few milliseconds, and the last few milliseconds. The top trace in all images is the adaptive output, while the bottom trace is the noise-corrupted input. The 60 Hz noise level was set at 100% of the biological spike amplitude. The weight modification factor &mu; was set to 2<sup>-10</sup>. <br>
    <br>
    <a href="NoiseCancel/Noise1full.jpg"><img src="NoiseCancel/Noise1full.jpg" width="331" height="250" border="0"></a> <a href="NoiseCancel/Noise1start.jpg"><img src="NoiseCancel/Noise1start.jpg" width="346" height="250" border="0"></a> <a href="NoiseCancel/Noise1end.jpg"><img src="NoiseCancel/Noise1end.jpg" width="342" height="250" border="0"></a><br>
    <br>
    <strong>Four tap 60 Hz and 180 Hz noise reduction</strong><br>
    The adaptive filter described above can be extended to filter 60 Hz plus the third harmonic at 180 Hz. Quite often there is significant 3rd harmonic distortion on the 110 volt power line, which would end up as experimental noise to be filtered. A <a href="NoiseCancel/Noise60hzAP2.m">matlab program</a> simulates the filter. Extending the filter to two frequencies requires more data in the form of memory of the input waveform. The <a href="NoiseCancel/Noise60hz2.v">top level module</a> for this filter has four adjustable filter weights and four different length ring buffers set to phase shifts of &pi;/2, &pi;/3, and &pi;/6 of a 60 Hz cycle. This <a href="NoiseCancel/RefSigAudio2.m">matlab program</a> acted as input to the FPGA with 3rd harmonic distortion similar to a square wave (30%). The resulting adaption is shown in the <a href="NoiseCancel/NoiseCancel2.MPG">mpeg</a>. The top trace is the adaptively filtered signal, and the bottom trace is the noisy input. Over 10 seconds you can see the signal emerge from the noise. The two folowing images show scope traces. The first shows the 60 Hz rapidly decreasing. The second shows the convergence after about 5 seconds.<br>
    <a href="NoiseCancel/Noise2start.jpg"><img src="NoiseCancel/Noise2start.jpg" width="349" height="250" border="0"></a> <a href="NoiseCancel/Noise2end.jpg"><img src="NoiseCancel/Noise2end.jpg" width="339" height="250" border="0"></a><br>
    <br>
    <br>
    <strong>Eight tap noise reduction</strong><br>
  Extending the filter to eight taps causes some instabilities to occur, apparently caused by overflow/underflow of the variable fixed point coefficients. The <a href="NoiseCancel/Noise60hz3.v">top level module</a> implements the filter with seven delay line lengths from 200 samples down to 40 samples, equally spaced. A <a href="NoiseCancel/RefSigAudio3.m">matlab code</a> supplied a test signal with fairly large second and third harmonic noise contribution. Not all phase shifts or amplitudes could be canceled, for reasons still to be determined.<br>
  <hr>
  </li>
  <li><strong>Using the Audio Codec</strong><br>
The <a href="../../../../../instruct1.cit.cornell.edu/courses/ece576/DE2_Datasheets/Audio%20CODEC/WM8731_WM8731L.pdf">audio codec</a> supports ADC conversion of microphone or line inputs into the FPGA, and DAC conversion of digital audio from the FPGA to line out. This example shows how to set up playback from the FPGA to line out. Using the original Terasic code, Playback is supported from flashRAM, SDRAM, SRAM or by direct on-the-fly synthesis. <br>
<br>
The logical structure of the hardware driver:<br>
<ul>
  <li>The top-level module just wires together the reset generator, PLL audio clock generator, the I2C codec configuration module and the audio DAC module. </li>
  <li>At reset, the <code>I2C_AV_config</code> module sends out data to configure eleven 9-bit registers in the audio codec using the <code>I2C_controller</code> communication module. The following table shows the configuration bit and the configuration used in the example.</li>
  <li>After the codec is configured, 16-bit, 2's complement, 48kHz, mono audio samples are sent to the DACDAT input of the codec using the <code>Audio_DAC</code> module The example uses audio samples generated by DDS.  Parker Evans (2008) wrote a <a href="../StudentWork/ParkerEvans/default.htm">modified verion</a> of the I2C controller and codec. His code generates an exact clock by using USB mode with a 12MHz Master Clock and Codec configured for 48KHz/48KHz sampling rates.<br>
    <table width="90%"  border="1">
      <tr>
        <td width="24%"><div align="center"><strong>Register num -- address -- Name </strong></div></td>
        <td width="33%"><div align="center"><strong>Functions</strong></div></td>
        <td width="43%"><div align="center"><strong>Example design data </strong></div></td>
      </tr>
      <tr>
        <td>R0 (00h) Left Line In </td>
        <td>b4:0 is line volume. <br>
          b7=1 mutes. <br>
          b8=1 locks line vol together. </td>
        <td>data=1a; almost full volume, no mute </td>
      </tr>
      <tr>
        <td>R1 (02h) Right Line In </td>
        <td>b4:0 is line volume. <br>
          b7=1 mutes. <br>
          b8=1 locks line vol together. </td>
        <td>data=1a; almost full volume, no mute </td>
      </tr>
      <tr>
        <td>R2 (04h) Left headphone out </td>
        <td>b6:0 is volume. <br>
          b7=1 enables zero crossing. <br>
          b8=1 locks vol together. </td>
        <td>data=7b; almost full volume. Lineout on the DE2 is connected to this output. </td>
      </tr>
      <tr>
        <td>R3 (06h) Right headphone out </td>
        <td>b6:0 is volume. <br>
          b7=1 enables zero crossing. <br>
          b8=1 locks vol together. </td>
        <td>data=7b; almost full volume. Lineout on the DE2 is connected to this output. </td>
      </tr>
      <tr>
        <td>R4 (08h) Analog Audio Path Control </td>
        <td><p>b0=1 is mic boost. <br>
          b1=1 is mic mute. <br>
          b2 selects input to ADC (mic=1 or line=0) <br>
          b3=1 enables bypass<br>
          b4=1 turns on DAC<br>
          b5=1 turns on sidetone<br>
          b7:6 is sidetone volume </p></td>
        <td>data=f8; no mic boost, no mic mute, line input to ADC, enable bypass, enable DAC, enable sidetone </td>
      </tr>
      <tr>
        <td>R5 (0ah) Digital Audio Path Control</td>
        <td>b0=1 disables highpass filter<br>
          b2:1 is de-emphasis control 11=48kHz, 10=44kHz, 01=32kHz, 00=disable <br>
          b3=1 is DAC soft mute<br>
          b4=1 stores DC offset </td>
        <td>data=06; enable highpass, 48kHz filter </td>
      </tr>
      <tr>
        <td>R6 (0ch) Power Down Control </td>
        <td>see data sheet </td>
        <td>data=00; turn it all on </td>
      </tr>
      <tr>
        <td>R7 (0eh) Digital Audio Interface Format </td>
        <td>b1:0 is format, use 01=MSB-first, left-justified <br>
          b3:2 is bit length, use 00=16 bits </td>
        <td>data=01; MSB, left, 16-bits </td>
      </tr>
      <tr>
        <td>R8 (10h) Sampling control </td>
        <td>b0=0 normal mode<br>
          b1=1 for best oversampling</td>
        <td>data=02; oversample </td>
      </tr>
      <tr>
        <td>R9 (12h) Active control </td>
        <td>b0=1 turns on codec </td>
        <td>data=01; crank it up! </td>
      </tr>
      <tr>
        <td>R15 (1eh) Reset control </td>
        <td>writing 0x00 resets</td>
        <td>not used </td>
      </tr>
    </table>
  </li>
</ul>
<br>
    <hr>
    <p><strong>References </strong></p>
    <p>JO Hamblen, TS Hall and MD Furman, <em>Rapid protoyping of digital systems, SPOC edition </em>, Springer 2008</p>
    <p>Antonio Di Stefano, Alessandro Scaglione, Costantino Giaconia, <em>Efficient FPGA Implementation of an Adaptive Noise Canceller</em>, IEEE Proceedings of the Seventh International Workshop on Computer Architecture for Machine Perception 2005 </p>
    <p>R. Ramos, A. MBnuel, G. Olivar, E. Trullols and J. Del Rio, <em>Application by means of FPGA of an adaptive caiiceller 50 Hz interference in electrocardiography</em>, IEEE Instrumentation and Measurement Technology Conference, Budapest, Hungary, May 21-23.2001.</p>
    <p>Dale Grover and John R. Deller, <em>Digital Signal Processing and the microcontroller</em> , Prentice-Hall/Motorola University Press 1999.</p>
    <hr>
    <br>
    <strong><span class="style2">Development History -- see top of page for current implementations! </span><br>
    </strong></li>
  <li><strong>Audio filter implementation</strong>s<br>
      <br>
      <strong>General second order IIR (18-bit) </strong>. <br>
    This example uses a serial multiply-and-accumulate (MAC) scheme to compute two second-order IIR filters in 6 cycles. Input is from the audio codec and output is back to the audio codec. The <a href="AudioFilter/AudioFilter1a.v">top-level module</a> implements a state machine clocked by the audio control clock (18 MHz) and synched to run once/audio sample (about 47 KHz). If the state machine was clocked from <code>clock_50</code> there were synch problems resulting in audio glitches. Each filter runs in parallel with all the other filters and each filter uses one 18-bit multiplier, so that you could implement up to about 35 filters. The filters use 18-bit, 2's complement notation with 16 bits of fraction for both the signal and the coefficients. This means that all filter coefficients have to be scaled to the range<code> -1&lt;coefficient&lt;1</code>. The matlab code to do the scaling and conversion to hex constants is at the end of the Verilog file as a comment. The matlab code to generate a frequency sweeping sine wave is also included at the end of the file. The whole project is <a href="AudioFilter/AudioFilter.zip">zipped here</a>. The actual filter form implemented was the <em>Direct Form Type I transposed</em> similar to what Matlab uses for its <code>filter</code> function. This means that the Matlab filter design funcitons (which yield the a's and b's) can be used to design filters. The form is shown below. The serial MAC operation steps through each of the terms on the right side of the equation, then divides by <code>a(1)</code>, if necessary. <br>
    <pre>a(1)*y(n) = b(1)*x(n) + b(2)*x(n-1) + ... + b(nb+1)*x(n-nb) 
                      - a(2)*y(n-1) - ... - a(na+1)*y(n-na)<br>
If a(1) is not equal to 1, you must divide the right side by a(1). </pre>
    The example has a Butterworth low pass filter with a normalized cutoff of 0.1 and an Butterworth bandpass filter with normalized cutoffs of [0.1 0.15]. The bandpass filter uses coefficients scaled by 0.5, so that the final MAC output has to be multiplied by two using a shift. Minor extensions to the state machine would allow higher order filters, but going too high causes numerical problems. Fourth order filters are probably safe, but sixth and higher should be carefully verified.<br>
    <br>
    <strong>General fourth order IIR (18-bit) .</strong><br>
    This example synthesizes a general 4th order IIR filter using the same serial scheme as above. The <a href="AudioFilter/AudioFilter1b.v">top-level module</a> has a few more states. The matlab programs to generate the coefficients is improved to generate Verilog directly and to plot the filter response. The matlab programs are included as comments at the end of the Verilog. In the image below, the blue line is the filter response calculated by matlab and the red dots are measured from a scope attached to the DE2 audio output. The logic used on the CycloneII FPGA for one filter is about 1.3% of the total available. The book <em>Digital Signal Processing and the microcontrolle</em>r was very useful for this code (see reference below). <br>
         <img src="AudioFilter/Butter4thOrder.png" width="560" height="420"><br>
         <strong>Modularized IIR Filter version (18-bit) .</strong><br>
    This example modularizes the IIR filters and simplifies the generation of filters by creating the filter Verilog code in Matlab. The current version of the <a href="AudioFilter/AudioFilter2.v">top-level module</a> has modules for 2, 4, and 6th-order IIRs. The matlab program is at the end of the Verilog file as a comment. This example also builds a pulse-width modulator (PWM) so that the LEDs on the DE2 can be used to indicate filter output. Typical Verilog filter code generated by the Matlab program is shown below. You must rename the module, and substitute in appropriate input and output variable names. The matlab program computes the a and b values, scales them to avoid overflow, and converts them to hex. The matlab program also plots the exact filter solution as well as the scaled 16-bit approximation. An example is shown below for normalized cutoffs (<code>frequency/(Fs/2)</code>) of<code> [0.1 0.2]</code>, 2nd order, and scaled by <code>&gt;&gt;&gt;2</code>. Always check the approximation to verify filter quality. <br>
    <pre>//Filter: cutoff=0.100000 
//Filter: cutoff=0.200000 
IIR4 filter( 
     .audio_out (your_out), 
     .audio_in (your_in), 
     .scale (3'd2), 
     .b1 (18'h149), 
     .b2 (18'h0), 
     .b3 (18'h3FD6E), 
     .b4 (18'h0), 
     .b5 (18'h149), 
     .a2 (18'hCD98), 
     .a3 (18'h2F54E), 
     .a4 (18'hA42E), 
     .a5 (18'h3D6F5), 
     .state_clk(AUD_CTRL_CLK), 
     .lr_clk(AUD_DACLRCK), 
     .reset(reset) 
) ; //end filter </pre>
    <img src="AudioFilter/ExactApprox4th.png" width="502" height="308"><br>
    <br>
    <strong>Modularized IIR Filter version (27-bit) .</strong><br>
    This example extends the precision of the filters to allow accurate, lower bandwidth filters. As before the code modularizes the IIR filters and simplifies the generation of filters by creating the filter Verilog code in Matlab. The current version of the <a href="AudioFilter27bit/AudioFilter2.v">top-level module</a> has modules for 2, 4, and 6th-order IIRs and a modified <code>signed_mult</code> routine. The matlab program is at the end of the Verilog file as a comment. This example also builds a pulse-width modulator (PWM) so that the LEDs on the DE2 can be used to indicate filter output. The matlab program computes the a and b values, scales them to avoid overflow, and converts them to hex. As in the last example, you must rename the module, and substitute in appropriate input and output variable names. The matlab program also plots the exact filter solution as well as the scaled 24-bit approximation. Always check the approximation to verify filter quality. The whole project is <a href="AudioFilter27bit/AudioFilter27bit.zip">zipped here</a>. Note that each filter uses 7 multipliers, so the maximum number of filters is 10. You could use these more expensive filters for narrow bandwidth fiters, which require more numerical accuracy, and 18-bit filters for higher bandwidth filters. A fairly narrow band filter (<code>[0.1 0.13]</code> at 47kHz sampling rate), six-pole filter is shown below. <br>
    <img src="AudioFilter27bit/NarrowBand.png" width="560" height="420"><br>
    <br>
    <strong>Filtering at 8 KHz sampling rate</strong> <strong> (18-bit).</strong><br>
    A sampling rate of 8 KHz is more appropriate for voice analysis. Three modifications are necessary to make the audio codec run at 8 KHz: (1) Change one status word in the codec initialization table in the <code><a href="AudioFilter8khz/I2C_AV_Config.v">I2C_AV_Config.v</a></code> module; (2) Change the sample rate constant in <code><a href="AudioFilter8khz/AUDIO_DAC_ADC.v">AUDIO_DAC_ADC.v</a></code> and change the lengths of the clock divider registers (<code>BCK_DIV, LRCK_1X_DIV, LRCK_2X_DIV, LRCK_4X_DIV</code>) so that they don't overflow because of the lower sample rate; (3) Change the audio clock PLL megawizard module (use the megawizard to edit <code><a href="AudioFilter8khz/VGA_Audio_PLL.v">VGA_Audio_PLL.v</a></code>) to use <code>CLOCK_50</code> and modify the input clock specification in the <a href="AudioFilter8khz/AudioFilter2.v">top_level module</a>. The whole project is <a href="AudioFilter8khz/AudioFilter8khzCodec.zip">zipped here</a>. Using the same audio filters as above, the band pass normalized frequency <code>[0.1 0.2]</code> is now at 400 to 800 Hz. <br>
    <br>
  To do: second order sections, FIR, multiple filters in one state machine 
  <hr>
  </li>
  <li><strong>IIR filters using a simple CPU</strong> <strong>with <a href="../../../../../instruct1.cit.cornell.edu/courses/ece576/DDA/index.htm">fixed point (2:16) multiplier</a></strong> <br>
    It is often handy to be able to write a program to filter, rather then generate a state machine. A small cpu (Hamblen chapter 9) was extended to act as a simple DSP unit by extending the data word length ot 18-bits, and adding a 2:16 multiply instruction. I wrote an <a href="AudioFilter/Filter18bitCPU/TinyASM18bit.m">assembler</a> for the cpu and a <a href="AudioFilter/Filter18bitCPU/ParameterFormatter.m">preprocessor</a> which takes filter specification input and generates a table of required coefficients in a format suitable for pasting into the assembler code as the <em>data section</em>. Note that the <code>'a'</code> filter coefficients are negated in the preprocessor so that only additions are necessary in the assembler code. Note also that the dynamic range of the filter constants is<code> +/-2</code>, so scaling is necessary <em>and must be specified by the user of the preprocessor (see example 4 above and the <a href="../../../../../instruct1.cit.cornell.edu/courses/ece576/DDA/index.htm">DDA page</a>!</em> A fourth-order filter assembler example is <a href="AudioFilter/Filter18bitCPU/Test18bitFilter.asm">here</a>. The  mif file resulting from the assembler is <a href="AudioFilter/Filter18bitCPU/Test18bitFilter.mif">here</a>, and has to be referenced near the end of the top-level module. The <a href="AudioFilter/Filter18bitCPU/AudioFilter3cpu.v">top-level module</a> builds one cpu and connects it to the audio i/o. The entire project is zipped <a href="AudioFilter/Filter18bitCPU/AudioFilter.zip">here</a>. The example filter is set to a bandpass of about 3.0 KHz (at 48kHz sample rate).  The top-level module resets the cpu on each left-right (stereo) clock transition (once per audio sample). The assembler code does not have a loop, except for a spin-halt at the end, because execution starts at reset for each audio sample. The cpu ISA is:<br>
	
<pre>instruction			effect
ADD addr        accum &lt;= accum + Mem(addr)		
STORE addr      Mem(addr) &lt;= accum	
LOAD addr       accum &lt;= Mem(addr)	
JMP addr        PC &lt;= addr	
JNEG addr       PC &lt;= (accum[17])? addr: PC
OUT addr        output(addr) &lt;= accum
IN addr         accum &lt;= input(addr)
MULT addr       accum &lt;= accum * Mem(addr) (signed 2:16 fraction)
SHL addr        accum &lt;= accum &lt;&lt; Mem(addr) (shift of 0 to 7 bits)
--single 18-bit accumulator
--addr is 12-bits</pre>
 The second example is a <a href="AudioFilter/Filter18bitCPU/TwoCPUs/AudioFilter3cpu.v">modifed top-level module version</a> with:<br>
 <ul> 
 <li>Improved clock synchronization between the cpu and audio. But note that the internal timing of the audio codec cannot be analysed by Quartus. Even a small lag in setting the data for one of the audio output channels will result in audio artifacts. </li>
 <li>A PLL to run the cpus at 100 MHz.</li> 
 <li>Two cpus to implement two independent filters.</li>
 </ul>
 The filter assembler source <em>data sections</em> are all that is different between <a href="AudioFilter/Filter18bitCPU/Test18bitFilter.asm">cpu1</a> and <a href="AudioFilter/Filter18bitCPU/Test18bitFilter2.asm">cpu2</a>.  The resulting two mif files (<a href="AudioFilter/Filter18bitCPU/Test18bitFilter.mif">cpu1</a>, <a href="AudioFilter/Filter18bitCPU/Test18bitFilter2.mif">cpu2</a>) are separately loaded into the respective cpu's M4K blocks. Note that the two cpu clocks are synced to CLOCK_50, while the cpu reset lines are synced to the audio control clock. Each 4-pole IIR filter takes 53 instructions to execute. Instructions are either 3 cycles or 5 cycles (for store). The number of cycles to execute each program is about 200 cycles, or two microseconds at 100 MHz. At a 48 KHz audio sample rate, about 10 four-pole filters could be run on each cpu, if there were enough memory for code and coefficients. One M4K block allows only about 3 four-pole filters to run. The entire project is zipped <a href="AudioFilter/Filter18bitCPU/TwoCPUs/AudioFilter.zip">here</a>. <br>
 <br>
 A <a href="AudioFilter/Filter18bitCPU/ThreeCPUs/AudioFilter3cpu.v">third example is further modified</a> to make a sum of filter outputs, which required changing the way the audio output was calculated to minimize lag with respect to the audio L/R DAC clock edge. Three filter outputs are added to make the left output channel. The filter assembler source <em>data sections</em> are all that is different between <a href="AudioFilter/Filter18bitCPU/Test18bitFilter.asm">cpu1</a>, <a href="AudioFilter/Filter18bitCPU/Test18bitFilter2.asm">cpu2</a> and <a href="AudioFilter/Filter18bitCPU/Test18bitFilter3.asm">cpu3</a>. The entire project is zipped <a href="AudioFilter/Filter18bitCPU/ThreeCPUs/AudioFilter.zip">here</a>. The Quartus archive is <a href="AudioFilter/Filter18bitCPU/ThreeCPUs/DE2_Default.qar">here</a>.
 <hr>
  </li>
  <li><strong>IIR filters using a parallel, pipelined design<br>
    </strong>This <a href="AudioFilterParallel/AudioFilter4parallel.v">verilog design</a> is closely related to the canonical, direct form II, for an IIR digital filter (Grover and Deller, page 254, figure 6-27).   The figure below is from  matlab documentation.<br>
    <img src="AudioFilterParallel/CanonicalIIR.gif" width="441" height="100">    <br>
  The filters are resource intensive compared to the state machine filters above, but they are very fast. The entire project is zipped <a href="AudioFilterParallel/AudioFilterParallel.zip">here</a>.
  <hr>
  </li>
  <li><strong>IIR filters using 18-bit floating point <br>
  </strong>The <a href="../FloatingPoint/index.html">floating point page</a> examples 3 and 4 implement filters using floating point arithmetic. Example 4 is more stable becuase it uses <a href="../../../../../en.wikipedia.org/wiki/Digital_biquad_filter">second-order-sections</a> (digital <i>biquadratic</i> sections) for the filters.</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
