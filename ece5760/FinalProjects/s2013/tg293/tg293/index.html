<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Anti Tetris</title>
<style type="text/css">
<!--
body {
	font: 100%/1.4 Verdana, Arial, Helvetica, sans-serif;
	background-color: #42413C;
	margin: 0;
	padding: 0;
	color: #000;
}

/* ~~ 元素/标签选择器 ~~ */
ul, ol, dl { /* 由于浏览器之间的差异，最佳做法是在列表中将填充和边距都设置为零。为了保持一致，您可以在此处指定需要的数值，也可以在列表所包含的列表项（LI、DT 和 DD）中指定需要的数值。请注意，除非编写一个更为具体的选择器，否则您在此处进行的设置将会层叠到 .nav 列表。 */
	padding: 0;
	margin: 0;
}
h1, h2, h3, h4, h5, h6, p {
	margin-top: 0;	 /* 删除上边距可以解决边距会超出其包含的 div 的问题。剩余的下边距可以使 div 与后面的任何元素保持一定距离。 */
	padding-right: 15px;
	padding-left: 15px;
}
a img { /* 此选择器将删除某些浏览器中显示在图像周围的默认蓝色边框（当该图像包含在链接中时） */
	border: none;
}
/* ~~ 站点链接的样式必须保持此顺序，包括用于创建悬停效果的选择器组在内。 ~~ */
a:link {
	color: #42413C;
	text-decoration: underline; /* 除非将链接设置成极为独特的外观样式，否则最好提供下划线，以便可从视觉上快速识别 */
}
a:visited {
	color: #6E6C64;
	text-decoration: underline;
}
a:hover, a:active, a:focus { /* 此组选择器将为键盘导航者提供与鼠标使用者相同的悬停体验。 */
	text-decoration: none;
}

/* ~~ 此固定宽度容器包含其它 div ~~ */
.container {
	width: 960px;
	background-color: #FFF;
	margin: 0 auto; /* 侧边的自动值与宽度结合使用，可以将布局居中对齐 */
}

/* ~~ 标题未指定宽度。它将扩展到布局的完整宽度。标题包含一个图像占位符，该占位符应替换为您自己的链接徽标 ~~ */
.header {
	background-color: #9c0200;
}

/* ~~ 这是布局信息。 ~~ 

1) 填充只会放置于 div 的顶部和/或底部。此 div 中的元素侧边会有填充。这样，您可以避免使用任何“方框模型数学”。请注意，如果向 div 自身添加任何侧边填充或边框，这些侧边填充或边框将与您定义的宽度相加，得出 *总计* 宽度。您也可以选择删除 div 中的元素的填充，并在该元素中另外放置一个没有任何宽度但具有设计所需填充的 div。

*/

.content {

	padding: 10px 0;
}

/* ~~ 脚注 ~~ */
.footer {
	padding: 10px 0;
	background-color: #CCC49F;
}

/* ~~ 其它浮动/清除类 ~~ */
.fltrt {  /* 此类可用于在页面中使元素向右浮动。浮动元素必须位于其在页面上的相邻元素之前。 */
	float: right;
	margin-left: 8px;
}
.fltlft { /* 此类可用于在页面中使元素向左浮动。浮动元素必须位于其在页面上的相邻元素之前。 */
	float: left;
	margin-right: 8px;
}
.clearfloat { /* 如果从 #container 中删除或移出了 #footer，则可以将此类放置在 <br /> 或空 div 中，作为 #container 内最后一个浮动 div 之后的最终元素 */
	clear:both;
	height:0;
	font-size: 1px;
	line-height: 0px;
}
-->
</style></head>

<body>

<div class="container">
  <div class="header"><a href="#"><img src="pics/CU-web-white.jpg" alt="在此处插入徽标" name="Insert_logo" width="364" height="91" id="Insert_logo" style="background-color: #C6D580; display:block;" /></a> 
    <!-- end .header --></div>
  <div class="content">
    <h1>Anti Tetris</h1>
    <h3>ECE 5760 Final Project</h3>
    <p>Tian Gao(tg293@cornell.edu)</p>
    <p><OBJECT width="640" height="360"  ><PARAM name="movie" value="MPFLVPlayer.swf" /><PARAM name="allowFullScreen" value="true" /><PARAM name="FlashVars" value="fn=../../../../../../../../www.youtube.com/watch@v=NE5GdK3eW8w@feature=player_detailpage&flvskin=MPFLVSkin.swf" /><EMBED src="MPFLVPlayer.swf"  width="640" height="360"  type="application/x-shockwave-flash" allowFullScreen="true" FlashVars="fn=../../../../../../../../www.youtube.com/watch@v=NE5GdK3eW8w@feature=player_detailpage&flvskin=MPFLVSkin.swf"></EMBED></OBJECT>s and how long the game lasts. The game screen is the combination of the real video stream and the tetris board so that the player can see how can they hit the blocks.   </p>
    <p><center></center></p>
<h2>High Level Design</h2>
<h3>Rationale</h3>
<p>Basically, the project could be divided into three parts: video signal decoding, hand detection and game playing. The camera provides a standard NTSC signal for FPGA and the FPGA has a hardware decoder which generates a serial digital signal. Altera has provided a solution to decode it to RGB system and display it on VGA screen. For hand detection, I first detect skin in YCbCr scale, then I track the hand by an iteration algorithm. The game is the similar as the original tetris, with the difference in width and height of the screen. Also you can't move or rotate the block, you can just eliminate it. </p>
<h3>Video Signal Decoding</h3>
<p>The controlling of the video game is based on hand gesture from the player, so a video camera is needed to capture the movement. The HTC video camera provides a standard NTSC signal which would be fed into video in port on DE2 board. There is a hardware NTSC decoder on board that gives out a ITU_R 656 serial signal which we can read on top module. Altera provides a solution to decode that signal to a YUV scale signal and downsample it from 720 to 640. After that it saves the output in SDRAM and then the VGA controller reads it out and transfer it to RGB scale. </p>
<h3>Hand Detection</h3>
<p>In the project, we need to detect hands on the screen for controlling. The basic idea is using YUV scale to filter out the skin and using a spacial average to stablize the output. There are two cursors on the screen that the player would have to put their haanti</p>
<p>nds on cursors first, then the cursor can tract the player's hands. Also, the program can distinguish it when the player push their hands, which is a signal for hitting the blocks. </p>
<h3>Game Playing</h3>
<p>The main goal of the game is to hit the tetriminos to avoid it falling down to the ground. There are two red cursors on screen indicating where your hands are. The player has to keep the cursors on his hands. The tetriminos are ramdomly falling down from the top of the screen. Once the player push his hands and the cursor is on the tetrimino, it disappears. The game would last until the top line of the screen is filled.</p>
<h2>Hardware Design</h2>
<h3>NTSC Decoding</h3>
<p>The NTSC decoding part of this project is from Bruce, which is an altera IP. The decoder converts the serial video signal to YUV scale and save that in DRAM. At the same time, the VGA controller constantly reads out the data that saved in DRAM. Since this is not a synchronized procedure, there are buffers for both input and output. However, the time of one frame for both reading and writing is the same, so from high level, reading and writing are synchronized. The decoder also downsamples the signal from 720 to 640 and mirrored it. The final output for VGA controller is RGB scale, but I filtered the signal in the middle of the decoder in YUV scale.</p>
<h3>Multiple Screen</h3>
<p>For this game, there are both game display and video output on the screen, so I used a MUX to solve the problem. I choose the YUV to RGB point to insert my logic circuit because that's the most convenient place to do my skin detection. I read the origin YUV value and then process it to generate the actual YUV signal for YUV to RGB block. As it's mentioned above, the skin information about the picture is saved in SRAM, and I used a 20*16 register for game display. The VGA_X and VGA_Y are the variables for MUX. The hand cursors has the highest priority, so if the position that VGA_X and VGA_Y determine is a cursor, it displays red. The game display has two parts: falling blocks and grounded blocks. Since it's too hard to track all the blocks as an individual module, all the grounded blocks are considered as a part of screen which would be saved in the register. Thus, we only need to track one active block. In general, the program would judge whether the pixel is cursor or filled screen or falling block, if not, put the decoded video signal directly.</p>
<h3>Hands Detecting</h3>
<p>Detecting hands is the most vital part in this game because that's the only controlling part. In this project, this part consists two steps.</p>
<p>Firstly, I try to detect all skin parts on the screen and save it on SRAM. People's skin shows an interesting feature in YUV scale that regardless of Y value, the Cb and Cr values are in a certain range, specifically, 80&lt;cb&lt;120 and 133&lt;cr&lt;173. Thus, we can detect skin in YUV scale, which is already provided in the process of decoding. However, this estimation is unstable and I can't save the result in SRAM because it's too fast. Therefore, I used a spacial average and downsampled it from 640*480 to 80*60. In this way, each big block has 16 pixels and only when there are more than 8 pixels of skin, can we consider that a skin. Also, in this way, I have four cycles for each block in a line, so I can both read and write in SRAM without losing frames.</p>
<p>After skin detection, I can get a binary 80*60 array in SRAM about where is the skin on screen, from which I can track the hand. I initially assume two positions for both hands on the screen. Once the actual hand is at that position, the iteration starts to track the hand. For every three frames(20 times/s), a tempory pointer goes top block by block(8 pixels * 8 pixels)from the &quot;hand position&quot; until the block is not skin. Then it's supposed to be the top of the hand. In same method, we can get the left, right and bottom of the hand and we can calculate the new position of hand by averaging the top/bot value and left/right value. In this way, we can constantly track the hands when it moves. To separate two hands on screen, I split the screen and the marker of the hand can't go through the middle of the screen.</p>
<p>Besides, we also need to distinguish the gesture &quot;push&quot; when the player tries to hit the falling blocks. In this case, I put the judgment in the hands position iteration. Initially it's assumed that the hand pushes. If the top position of the hand is lower than last time or the bottom position is higher than last time, the assumption is wrong, otherwise, we can say that the player pushes. This easy method may cause some false positive, but it's cheap and the false positive is not very harmful for the game.</p>
<p><center></center></p>
<h3>Single Block</h3>
<p>As we know, all tetriminos are composed of four single squares. Therefore, I designed a single square block at first. How to display a square on VGA screen efficiently is a tricky thing on verilog, so I built a module that's compatible with my structure. For this VGA_Square module, the main function is by inputing VGA_X and VGA_Y, outputing a binary signal for whether the pixel is filled. The module has three internal variables: X, Y and Speed. For every cycle(in this project, 2 frames), the Y value increases by Speed. The block can be disabled and stopped for future controlling.</p>
<h3>Tetrimino</h3>
<p>A tetrimino is composed of four single square, so there are four single block modules in a tetrimino module. Basically, the tetrimino module provides a similar function as the square one. However, since the tetrimimo module has to communicate with top module, there are some extra IOs in the module. </p>
<p>First of all, the module communicates with top module with hand shake protocol so that different frequency of clocks wouldn't be a problem. Since the tetrimino could be erased at any time, it has a reset signal that could be triggered any time to disable and reset the block.</p>
<p>Also, there are many types of tetriminos: seven in total without rotation, so the module has a type signal and a angle signal which can determine the shape of the tetrimino. I added an extra kind of tetrimino which is exactly the same as the square with different color. The new kind of tetrimino can erase the blocks under it when it's grounded instead of being a part of it. </p>
<p>As we can see, the tetrimino is falling from the top of the screen so four squares are not all visible initially. Thus, I used a state machine to manage the sequence of four squares. I set them up at the same time with minus Y values but only enable the block when it's on the first line. The state machines are different if the type/angle are different. </p>
<p>At last, the module has to communicate with the game display register. If the tetrimino falls onto a filled block, it should be grounded. Thus, the screen_filled register is the input of this module. However, we need to refresh the register which can't be done inside the module, so when the tetrimino falls onto the ground, the state machine in top module would update the register.</p><center>
</center></p>
<h2>Results</h2>
<p>For final results, I finished the game and made it pretty playable. The start menu is as follows:</p>
<p><img src="pics/IMG_0169.JPG" width="600" height="804" /></p>
<p>The red cursors in the screen is the hand tracking target, which are not tracking anything now. Player needs to push both hand together to start the game.</p>
<p><img src="pics/IMG_0171.JPG" width="600" height="804" /></p>
<p>The game display is like above.</p>
<p>The refresh rate for background, falling blocks and skin detection are different, but the slowest of them is 20Hz. Consequently, the game screen is smooth without any blinking that can be experienced by human eyes. There is no artifacts on the screen but the skin detection is a little bit unstable.</p>
<h2>Conclusion</h2>
<p>In the project, I designed a gesture controlled video game &quot;Anti Tetris&quot; on altera DE2 board with an NTSC camera. By implementing a skin detection algorithm, the game can track hands on screen and detect the push. The player is supposed to hit the falling blocks to avoid it falling down. The final score: game time and erasing numbers are displayed on board. </p>
<p>The game provides a good exercise opportunity because it takes efforts to keep pushing for a minute or more. Other than that, this is a safe non-distrubing quiet game for all people. For future developing, more playing option may be implemented. For example, the game could recognize the gesture of the player so the player can move or rotate the tetriminos, which would make it a real tetris game. Also, the display is not fancy at all now, it could be better.</p>
<h2><!-- end .content -->Appendix</h2>
<h3>Code</h3>
<p><a href="code/DE2_TV.v">DE2_TV.v</a></p>
<p><a href="code/VGA_Square.v">VGA_Square.v</a></p>
<h3>References</h3>
<p><a href="../../../../default.htm">http://people.ece.cornell.edu/land/courses/ece5760/</a></p>
<p> <a href="../../../../../../../../www.wseas.us/e-library/conferences/2011/Mexico/CEMATH/CEMATH-20.pdf">http://www.wseas.us/e-library/conferences/2011/Mexico/CEMATH/CEMATH-20.pdf</a></p>
<p><a href="../../../../../../../../www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.656-5-200712-I!!PDF-E.pdf">http://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.656-5-200712-I!!PDF-E.pdf</a></p>
  </div>
  <div class="footer">
    <p>ECE 5760 @ School of Electrical and Computer Engineering, Cornell University</p>
    <!-- end .footer --></div>
  <!-- end .container --></div>
</body>
</html>
