<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=big5">
<title>Design</title>
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="File-List" href="DESIGN_files/filelist.xml">

<style>
<!--
 p.MsoNormal
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";
	margin-left:0in; margin-right:0in; margin-top:0in}
-->
</style>
<!--[if !mso]>
<style>
v\:*         { behavior: url(#default#VML) }
o\:*         { behavior: url(#default#VML) }
.shape       { behavior: url(#default#VML) }
</style>
<![endif]--><!--[if gte mso 9]>
<xml><o:shapedefaults v:ext="edit" spidmax="1027"/>
</xml><![endif]-->
<!--mstheme--><link rel="stylesheet" type="text/css" href="_themes/folio/foli1011-105.css"><meta name="Microsoft Theme" content="folio 1011, default">
<meta name="Microsoft Border" content="none, default">
</head>

<body>

<table border="0" cellpadding="0" cellspacing="0" width="1056" height="835" id="table1">
	<!-- MSTableType="layout" -->
	<tr>
		<td valign="top">
		<!-- MSCellType="DecArea" -->
		¡@</td>
		<td valign="top" height="114">
		<!-- MSCellType="ContentHead" -->
		<p class="MsoNormal" align="center" style="text-align: center">¡@</p>
		<p class="MsoNormal" align="center" style="text-align: center">
		<font face="Arial" size="7"><span lang="EN-US">The Design</span></font></td>
	</tr>
	<tr>
		<td valign="top" width="182">
		<!-- MSCellType="NavBody" -->
		<font face="Arial">
		<!--webbot bot="Navigation" S-Orientation="vertical" S-Rendering="graphics" S-Type="siblings" B-Include-Home="TRUE" B-Include-Up="FALSE" startspan --><script language="JavaScript"><!--
MSFPhover = 
  (((navigator.appName == "Netscape") && 
  (parseInt(navigator.appVersion) >= 3 )) || 
  ((navigator.appName == "Microsoft Internet Explorer") && 
  (parseInt(navigator.appVersion) >= 4 ))); 
function MSFPpreload(img) 
{
  var a=new Image(); a.src=img; return a; 
}
// --></script><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav1n=MSFPpreload("_derived/home_cmp_folio010_vbtn.gif"); MSFPnav1h=MSFPpreload("_derived/home_cmp_folio010_vbtn_a.gif"); }
// --></script><a href="index.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1h.src" onmouseout="if(MSFPhover) document['MSFPnav1'].src=MSFPnav1n.src"><img src="_derived/home_cmp_folio010_vbtn.gif" width="140" height="35" border="0" alt="Home" name="MSFPnav1"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav2n=MSFPpreload("_derived/BG.htm_cmp_folio010_vbtn.gif"); MSFPnav2h=MSFPpreload("_derived/BG.htm_cmp_folio010_vbtn_a.gif"); }
// --></script><a href="BG.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2h.src" onmouseout="if(MSFPhover) document['MSFPnav2'].src=MSFPnav2n.src"><img src="_derived/BG.htm_cmp_folio010_vbtn.gif" width="140" height="35" border="0" alt="Background" name="MSFPnav2"></a><br><img src="_derived/DESIGN.htm_cmp_folio010_vbtn_p.gif" width="140" height="35" border="0" alt="Design"><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav3n=MSFPpreload("_derived/RESULT.htm_cmp_folio010_vbtn.gif"); MSFPnav3h=MSFPpreload("_derived/RESULT.htm_cmp_folio010_vbtn_a.gif"); }
// --></script><a href="RESULT.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3h.src" onmouseout="if(MSFPhover) document['MSFPnav3'].src=MSFPnav3n.src"><img src="_derived/RESULT.htm_cmp_folio010_vbtn.gif" width="140" height="35" border="0" alt="Results" name="MSFPnav3"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav4n=MSFPpreload("_derived/other_considerations.htm_cmp_folio010_vbtn.gif"); MSFPnav4h=MSFPpreload("_derived/other_considerations.htm_cmp_folio010_vbtn_a.gif"); }
// --></script><a href="other_considerations.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4h.src" onmouseout="if(MSFPhover) document['MSFPnav4'].src=MSFPnav4n.src"><img src="_derived/other_considerations.htm_cmp_folio010_vbtn.gif" width="140" height="35" border="0" alt="Considerations" name="MSFPnav4"></a><br><script language="JavaScript"><!--
if(MSFPhover) { MSFPnav5n=MSFPpreload("_derived/REF.htm_cmp_folio010_vbtn.gif"); MSFPnav5h=MSFPpreload("_derived/REF.htm_cmp_folio010_vbtn_a.gif"); }
// --></script><a href="REF.htm" language="JavaScript" onmouseover="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5h.src" onmouseout="if(MSFPhover) document['MSFPnav5'].src=MSFPnav5n.src"><img src="_derived/REF.htm_cmp_folio010_vbtn.gif" width="140" height="35" border="0" alt="Resources" name="MSFPnav5"></a><!--webbot bot="Navigation" i-checksum="65343" endspan --></font></td>
		<td valign="top" height="721" width="874">
		<!-- MSCellType="ContentBody" -->
		<p class="MsoNormal">¡@</p>
		<p class="MsoNormal" style="text-indent:24.0pt">
		<span lang="EN-US" style="font-size:16.0pt;font-family:Arial;color:black">
		High-level Description</span></p>
		<p class="MsoNormal">
		<span lang="EN-US" style="font-family:Arial;color:black">&nbsp;</span></p>
		<p class="MsoNormal" style="margin-left:24.0pt">
		<span lang="EN-US" style="font-family:Arial;color:black">We used the 
		camera module provided by Terasic to capture two frames of images and 
		stored them into SDRAM. To store both images in the SDRAM, we split the SDRAM into two partitions. Before we stored them into the SDRAM, 
		we converted </span><span style="font-family: Arial; color: black">the 
		images into black and white. This was to conserve temporary storage, for 
		both SRAM and registers, and to speed up the compiling and synthesizing 
		time. Also, because the camera was natively only one CCD, the conversion 
		did not lose more content.<span style="font-family:Arial;color:black"> Since we expected 
		that the number of logic elements required to compute all partitions was 
		too large for our FPGA, we decided to select the search area and reference box to 
		be in the middle of the screen and only worked in this search area to 
		demonstrate that our design was fully functional. It could be scaled-up to 
		compute the full image if we have more resources. Instead of drawing a 
		straight line, we outlined the entire search area and shaded the box with the 
		minimum sum of absolute differences within the search area to see the 
		output more clearly. The data for the outlines were not written back to 
		the SDRAM. Instead, we just added the outline to the image when writing 
		to the VGA buffer in SRAM. When we completed the design, we expected to 
		see a black and white image with two outlines in the middle of the 
		screen, and the smaller box would move around to track movement. Please 
		refer to the Results section for more information. <i>Figure 1</i> below 
		is a schematic for the algorithm, and <i>Figure 2</i> is a high-level block diagram for the design.</span></span></p>
		<p class="MsoNormal" style="margin-left:24.0pt">
		¡@</p>
		<p class="MsoNormal" style="margin-left:72.1pt" align="center">
		<img border="0" src="images/DESIGN13.gif"></p>
		<p class="MsoNormal" style="text-align: center; margin-left: 24.0pt" align="center">
		<font face="Arial"><i>Figure 1: The implemented algorithm</i></font></p>
		<p class="MsoNormal" style="margin-left:72.1pt">¡@</p>
		<p class="MsoNormal" align="center" style="margin-left:72.1pt;text-align:center">
		<font face="Arial"><span lang="EN-US"><!--[if gte vml 1]><v:shapetype id="_x0000_t75"
 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe"
 filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_s1026" type="#_x0000_t75" style='width:434.25pt;
 height:192pt'>
 <v:imagedata src="DESIGN_files/image001.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img border=0 width=579 height=256
src="DESIGN_files/image002.gif" v:shapes="_x0000_s1026"><![endif]></span></font></p>
		<p class="MsoNormal" align="center" style="margin-left:24.0pt;text-align:center">
		<font face="Arial"><i><span lang="EN-US">Figure 1: A high-level block 
		diagram</span></i></font></p>
		<p class="MsoNormal" align="center" style="margin-left:24.0pt;text-align:center">¡@</p>
		<p class="MsoNormal" style="text-indent:24.0pt">
		<span lang="EN-US" style="font-size:16.0pt;font-family:Arial;color:black">
		Camera Module</span></p>
		<p class="MsoNormal"><span lang="EN-US" style="color:black">&nbsp;</span></p>
		<p class="MsoNormal" style="margin-left:24.0pt">
		<span lang="EN-US" style="font-family:Arial;color:black">The camera 
		module we used came with a driver that was set up properly to capture 
		images using a CMOS sensor. The data was processed, stored in SDRAM 
		and sent to the VGA buffer, an SRAM, to display the image on screen. The 
		driver helped us capture the images easily. The following is a picture 
		of the setup:</span></p>
		<p class="MsoNormal">¡@</p>
		<p class="MsoNormal" align="center" style="margin-left:72.1pt;text-align:center">
		<font face="Arial"><span lang="EN-US" style="font-size: 10.0pt">&nbsp;</span></font></p>
		<p class="MsoNormal" align="center" style="margin-left:72.1pt;text-align:center">
		<span lang="EN-US"><font face="Arial"><!--[if gte vml 1]><v:shape
 id="_x0000_s1025" type="#_x0000_t75" style='width:477pt;height:339pt'>
 <v:imagedata src="DESIGN_files/image003.png" o:title=""/>
</v:shape><![endif]--><![if !vml]><img border=0 width=636 height=452
src="DESIGN_files/image004.jpg" v:shapes="_x0000_s1025"><![endif]></font><!--[if gte mso 9]><![endif]--></span></p>
		<p class="MsoNormal" align="center" style="margin-left:72.8pt;text-align:center">
		<font face="Arial"><i><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Figure 2: An Altera DE2 
		board with camera module</span></i></font></p>
		<p class="MsoNormal"><font face="Arial"><span lang="EN-US">&nbsp;</span></font></p>
		<p class="MsoNormal" style="margin-left:24.0pt">
		<span lang="EN-US" style="font-family:Arial;color:black">The line buffer 
		in the provided driver would read raw data from the sensor. The CMOS 
		sensor would produce a raw data like the diagram in <i>Figure 4</i>, where 
		each pixel would only contain one component of red, blue, or green. 
		Since the intensity of green should be twice the blue and red, there are 
		twice as many pixels of green than blue or red. This is commonly 
		referred to as the Bayer representation. However, the VGA display needs 
		all three components in one pixel to display properly, so the pixel 
		stored in the SDRAM would be a combination of all three components. 
		Depending on position of the pixel, the combination of colors would be 
		different. To determine the component contents, we would first need to 
		scan in two lines from the camera keep track of which four pixels to 
		look at, and the extract the data and put them into the SDRAM. </span>
		<font face="Arial"><span lang="EN-US" style="font-size: 12.0pt">More 
		information about the camera and how it works can be found from the 
		documentation of the device </span></font>
		<span lang="EN-US" style="font-size: 12.0pt">
		<a style="color: blue; text-decoration: underline; text-underline: single" href="../../../../../../../../www.terasic.com.tw/attachment/archive/50/TRDB_DC2_UserGuide_061017.pdf">
		<font face="Arial">here</font></a></span><span lang="EN-US" style="font-size: 12.0pt; font-family: Times New Roman">.
		</span><span lang="EN-US" style="font-family:Arial;color:black">The following code was used to determine the component of each 
		pixel (provided by driver):</span></p>
		<p class="MsoNormal"><font face="Arial"><span lang="EN-US">:</span></font></p>
		<p class="MsoNormal" align="center" style="margin-left:1.0in;text-align:center">
		<font face="Arial"><img border="0" src="images/DESIGN8.gif"></font></p>
		<p class="MsoNormal" align="center" style="margin-left:1.0in;text-align:center">
		<font face="Arial"><i><span lang="EN-US">Figure 3: codes to determine 
		the components in each pixel in SDRAM</span></i></font></p>
		<p class="MsoNormal" align="center" style="margin-left:1.0in;text-align:center">¡@</p>
		<p class="MsoNormal" align="center" style="margin-left:72.1pt;text-align:center">
		<font face="Arial"><img border="0" src="images/DESIGN9.gif"></font></p>
		<p class="MsoNormal" align="center" style="margin-left:72.8pt;text-align:center">
		<font face="Arial"><i><span lang="EN-US">Figure 4: A schematic for Bayer 
		filter</span></i></font></p>
		<p class="MsoNormal" align="center" style="margin-left:72.8pt;text-align:center">
		<font face="Arial"><i><span lang="EN-US">&nbsp;</span></i></font></p>
		<p class="MsoNormal" style="text-indent:24.0pt">
		<span lang="EN-US" style="font-size:16.0pt;font-family:Arial;color:black">
		Memory Setup</span></p>
		<p class="MsoNormal"><span lang="EN-US" style="color:black">&nbsp;</span></p>
		<p class="MsoNormal" style="margin-left:24.0pt">
		<span lang="EN-US" style="font-family:Arial;color:black">We used both 
		SDRAM and SRAM for this system. A FIFO SDRAM was used to store the 
		data from the camera, and the SRAM was used for VGA buffer before 
		the image was sent to the VGA display. The SDRAM controller took in a 
		starting address, an ending address, a clock and the length of the data 
		stream. The controller would then fetch data from or write data to the 
		specified address on each clock cycle. Since we wanted to store two 
		images into the SDRAM, we needed to partition the RAM into two sections. 
		The size of the picture is 640x512, and the starting address of image 1 
		was set to 0, so the starting address of image 2 was set to 22¡¦h100000 
		(a lot bigger than needed) to avoid overwriting the first image. The 
		length of the data stream was 256. Therefore,&nbsp; the Verilog code for 
		writing and reading the FIFO SDRAM looks like the following:</span></p>
		<p class="MsoNormal">¡@</p>
		<p class="MsoNormal" align="center"><font face="Arial">
		<img border="0" src="images/DESIGN10.gif"></font></p>
		<p class="MsoNormal" align="center" style="margin-left:24.0pt;text-align:center">
		<font face="Arial"><i><span lang="EN-US">Figure 5: FIFO SDRAM controller 
		connection</span></i></font></p>
		<p class="MsoNormal"><font face="Arial"><span lang="EN-US">&nbsp;</span></font></p>
		<p class="MsoNormal" style="margin-left:24.0pt">
		<span lang="EN-US" style="font-family:Arial;color:black">The SRAM was 
		used to buffer output image for the VGA display. SRAM could be accessed by 
		specifying the address and the data, without accessing data in order, which is much easier to access than 
		the SDRAM. After we computed the minimum sum of absolute differences we 
		needed to modify the image by overlaying the outlines on the original 
		image. We could do this by setting the new 16-bit data to the SRAM when 
		we went through each pixel and updated the buffer at the corresponding 
		address during synchronization. A special feature was introduced here. 
		We were able to draw the boxes in color though our image was in black 
		and white. This was achieved by concatenating the 10-bit black and white 
		information with 6-bits of color information with only one of the 6 bits 
		being high. Therefore, the colors would become more noticeable when the 
		neighboring pixels were darker, and less noticeable when the neighboring 
		pixels were brighter. Essentially, if the search area was black, all 
		three colors would show, but if the search area was white, no color 
		would show. The following code was used to draw the 
		red outline for the reference box to the SRAM after the computation was 
		complete:</span></p>
		<p class="MsoNormal">¡@</p>
		<p class="MsoNormal">¡@</p>
		<p class="MsoNormal" align="center" style="margin-left:72.8pt;text-align:center">
		<font face="Arial"><img border="0" src="images/DESIGN11.gif"></font></p>
		<p class="MsoNormal" align="center" style="margin-left:72.8pt;text-align:center">
		<font face="Arial"><i><span lang="EN-US">Figur 6 : codes to write the 
		red outline to the VGA buffer</span></i></font></p>
		<p class="MsoNormal">¡@</p>
		<p class="MsoNormal" style="text-indent:24.0pt">
		<span lang="EN-US" style="font-size:16.0pt;font-family:Arial;color:black">
		Computation</span></p>
		<p class="MsoNormal"><span lang="EN-US" style="color:black">&nbsp;</span></p>
		<p class="MsoNormal" style="margin-left:24.0pt">
		<span lang="EN-US" style="font-family:Arial;color:black">After the data 
		was stored in the SDRAM, and the reference area and search area were 
		defined, we would extract the data from all the pixels within both areas 
		and put them into 10-bit registers on the FPGA. Then we compute the sum of absolute 
		difference between the reference box and the candidate match area. With 
		our definition, it would take 16x16 = 256 cycles to complete the entire 
		computation since our search area was 24x24 and the reference area was 
		8x8. To 
		compute the absolute difference between two pixels in hardware, we first 
		compared the values of the data, and then we subtracted the smaller one 
		from the larger one. After we compute the first iteration, we kept sum 
		and a temporary register, and every iteration, we compared the sum with 
		the temporary register to keep track of which match area in the search 
		area has the smallest sum. When the entire search area had been gone 
		through, a flag, doneproc, was asserted and the state became &quot;done.&quot; The state machine was used to 
		help control the sequence of events happening. We only compared the 
		two most significant bits of the data because the noise floor was quite 
		high and the information after the third bit was not helpful for 
		comparison between the two data but made the number of logic elements 
		increase by a lot. In this case, if we performed a Gaussian filtering, 
		we could increase the signal-to-noise ratio, and we could detect motion 
		in images that have less intensity contrast. However, due to time 
		constraint, we were not able to include that in our project. </span></p>
		<p class="MsoNormal" style="margin-left:24.0pt">¡@</p>
		<p class="MsoNormal" align="center" style="margin-left:24.0pt;text-align:center">
		<font face="Arial"><img border="0" src="images/DESIGN12.gif"></font></p>
		<p class="MsoNormal" align="center" style="margin-left:72.8pt;text-align:center">
		<font face="Arial"><i><span lang="EN-US">Figure 7: The state diagram of 
		the computation stage</span></i></font></p>
		<p class="MsoNormal"><font face="Arial"><span lang="EN-US">&nbsp;</span></font></p>
		<p class="MsoNormal" style="text-indent:24.0pt">
		<span lang="EN-US" style="font-size:16.0pt;font-family:Arial;color:black">
		VGA Display</span></p>
		<p class="MsoNormal"><span lang="EN-US" style="color:black">&nbsp;</span></p>
		<p class="MsoNormal" style="margin-left:24.0pt">
		<span lang="EN-US" style="font-family:Arial;color:black">To use the VGA 
		output on the DE2 board, we used to use the controller that came with 
		the DE2 board. When the ¡§sync¡¨ bit was set, the controller would output 
		the in the VGA buffer onto the screen. The VGA buffer was an SRAM that 
		contained 10-bit RGB data. Since we were only using grey scale for 
		simplicity, we only needed one SRAM to display. After the computation 
		with the done, the pictures needed&nbsp; to be mirrored before writing 
		to the FIFO SDRAM in order to get the correct image when reading out the data. Essentially, 
		we modified the VGA driver that Professor Land wrote in his DLA code to 
		help work with SDRAM.</span></p>
		<p class="MsoNormal">¡@</td>
	</tr>
</table>

</body>

</html>
