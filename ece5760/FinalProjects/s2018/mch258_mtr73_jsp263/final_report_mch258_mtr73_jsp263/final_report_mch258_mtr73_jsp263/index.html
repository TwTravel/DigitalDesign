<html><head><title>Mandelbrot Set Renderer - Final Report - ECE 5760</title><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('../../../../../../../../../https@themes.googleusercontent.com/fonts/css@kit=lhDjYqiy3mZ0x6ROQEUoUw');ul.lst-kix_pfbgyy9oylnq-1{list-style-type:none}ul.lst-kix_pfbgyy9oylnq-0{list-style-type:none}ul.lst-kix_pfbgyy9oylnq-8{list-style-type:none}ul.lst-kix_pfbgyy9oylnq-7{list-style-type:none}ul.lst-kix_pfbgyy9oylnq-6{list-style-type:none}ul.lst-kix_pfbgyy9oylnq-5{list-style-type:none}ul.lst-kix_az7bl1pfkw68-2{list-style-type:none}ul.lst-kix_pfbgyy9oylnq-4{list-style-type:none}ul.lst-kix_az7bl1pfkw68-3{list-style-type:none}ul.lst-kix_pfbgyy9oylnq-3{list-style-type:none}ul.lst-kix_az7bl1pfkw68-0{list-style-type:none}ul.lst-kix_pfbgyy9oylnq-2{list-style-type:none}ul.lst-kix_az7bl1pfkw68-1{list-style-type:none}ul.lst-kix_az7bl1pfkw68-6{list-style-type:none}.lst-kix_f4ptf2dk4m7q-8>li:before{content:"\0025a0  "}ul.lst-kix_az7bl1pfkw68-7{list-style-type:none}ul.lst-kix_az7bl1pfkw68-4{list-style-type:none}ul.lst-kix_az7bl1pfkw68-5{list-style-type:none}ul.lst-kix_az7bl1pfkw68-8{list-style-type:none}ul.lst-kix_n4t0jjjyghmc-0{list-style-type:none}.lst-kix_f4ptf2dk4m7q-0>li:before{content:"\0025cf  "}.lst-kix_f4ptf2dk4m7q-1>li:before{content:"\0025cb  "}.lst-kix_f4ptf2dk4m7q-2>li:before{content:"\0025a0  "}ul.lst-kix_n4t0jjjyghmc-8{list-style-type:none}ul.lst-kix_n4t0jjjyghmc-7{list-style-type:none}.lst-kix_79mriyjx9jew-8>li:before{content:"-  "}ul.lst-kix_n4t0jjjyghmc-6{list-style-type:none}ul.lst-kix_n4t0jjjyghmc-5{list-style-type:none}.lst-kix_21m4sv2kce77-7>li:before{content:"-  "}ul.lst-kix_n4t0jjjyghmc-4{list-style-type:none}ul.lst-kix_n4t0jjjyghmc-3{list-style-type:none}ul.lst-kix_n4t0jjjyghmc-2{list-style-type:none}ul.lst-kix_n4t0jjjyghmc-1{list-style-type:none}.lst-kix_21m4sv2kce77-8>li:before{content:"-  "}.lst-kix_f4ptf2dk4m7q-7>li:before{content:"\0025cb  "}.lst-kix_21m4sv2kce77-3>li:before{content:"-  "}.lst-kix_21m4sv2kce77-5>li:before{content:"-  "}.lst-kix_f4ptf2dk4m7q-5>li:before{content:"\0025a0  "}.lst-kix_f4ptf2dk4m7q-6>li:before{content:"\0025cf  "}.lst-kix_21m4sv2kce77-2>li:before{content:"-  "}.lst-kix_21m4sv2kce77-6>li:before{content:"-  "}.lst-kix_f4ptf2dk4m7q-3>li:before{content:"\0025cf  "}.lst-kix_f4ptf2dk4m7q-4>li:before{content:"\0025cb  "}.lst-kix_21m4sv2kce77-4>li:before{content:"-  "}.lst-kix_az7bl1pfkw68-2>li:before{content:"-  "}.lst-kix_79mriyjx9jew-7>li:before{content:"-  "}.lst-kix_az7bl1pfkw68-1>li:before{content:"-  "}.lst-kix_79mriyjx9jew-6>li:before{content:"-  "}.lst-kix_79mriyjx9jew-5>li:before{content:"-  "}.lst-kix_az7bl1pfkw68-0>li:before{content:"-  "}ul.lst-kix_f4ptf2dk4m7q-6{list-style-type:none}.lst-kix_79mriyjx9jew-3>li:before{content:"-  "}ul.lst-kix_f4ptf2dk4m7q-5{list-style-type:none}ul.lst-kix_f4ptf2dk4m7q-8{list-style-type:none}.lst-kix_79mriyjx9jew-2>li:before{content:"-  "}.lst-kix_79mriyjx9jew-4>li:before{content:"-  "}ul.lst-kix_f4ptf2dk4m7q-7{list-style-type:none}ul.lst-kix_f4ptf2dk4m7q-2{list-style-type:none}ul.lst-kix_f4ptf2dk4m7q-1{list-style-type:none}ul.lst-kix_f4ptf2dk4m7q-4{list-style-type:none}ul.lst-kix_f4ptf2dk4m7q-3{list-style-type:none}ul.lst-kix_f4ptf2dk4m7q-0{list-style-type:none}.lst-kix_79mriyjx9jew-0>li:before{content:"-  "}.lst-kix_79mriyjx9jew-1>li:before{content:"-  "}.lst-kix_az7bl1pfkw68-3>li:before{content:"-  "}.lst-kix_az7bl1pfkw68-4>li:before{content:"-  "}.lst-kix_az7bl1pfkw68-5>li:before{content:"-  "}.lst-kix_n4t0jjjyghmc-8>li:before{content:"\0025a0  "}.lst-kix_az7bl1pfkw68-6>li:before{content:"-  "}.lst-kix_az7bl1pfkw68-7>li:before{content:"-  "}.lst-kix_az7bl1pfkw68-8>li:before{content:"-  "}ul.lst-kix_79mriyjx9jew-0{list-style-type:none}.lst-kix_n4t0jjjyghmc-7>li:before{content:"\0025cb  "}.lst-kix_n4t0jjjyghmc-6>li:before{content:"\0025cf  "}.lst-kix_n4t0jjjyghmc-5>li:before{content:"\0025a0  "}ul.lst-kix_79mriyjx9jew-8{list-style-type:none}.lst-kix_n4t0jjjyghmc-3>li:before{content:"\0025cf  "}ul.lst-kix_79mriyjx9jew-7{list-style-type:none}ul.lst-kix_79mriyjx9jew-6{list-style-type:none}.lst-kix_n4t0jjjyghmc-2>li:before{content:"\0025a0  "}.lst-kix_n4t0jjjyghmc-4>li:before{content:"\0025cb  "}ul.lst-kix_79mriyjx9jew-5{list-style-type:none}ul.lst-kix_79mriyjx9jew-4{list-style-type:none}ul.lst-kix_79mriyjx9jew-3{list-style-type:none}ul.lst-kix_79mriyjx9jew-2{list-style-type:none}ul.lst-kix_79mriyjx9jew-1{list-style-type:none}.lst-kix_n4t0jjjyghmc-0>li:before{content:"\0025cf  "}.lst-kix_n4t0jjjyghmc-1>li:before{content:"\0025cb  "}.lst-kix_pfbgyy9oylnq-8>li:before{content:"-  "}.lst-kix_pfbgyy9oylnq-7>li:before{content:"-  "}.lst-kix_pfbgyy9oylnq-5>li:before{content:"-  "}.lst-kix_pfbgyy9oylnq-4>li:before{content:"-  "}.lst-kix_pfbgyy9oylnq-6>li:before{content:"-  "}.lst-kix_pfbgyy9oylnq-1>li:before{content:"-  "}.lst-kix_pfbgyy9oylnq-2>li:before{content:"-  "}.lst-kix_21m4sv2kce77-1>li:before{content:"-  "}.lst-kix_pfbgyy9oylnq-3>li:before{content:"-  "}.lst-kix_21m4sv2kce77-0>li:before{content:"-  "}.lst-kix_pfbgyy9oylnq-0>li:before{content:"-  "}ul.lst-kix_21m4sv2kce77-2{list-style-type:none}ul.lst-kix_21m4sv2kce77-1{list-style-type:none}ul.lst-kix_21m4sv2kce77-4{list-style-type:none}ul.lst-kix_21m4sv2kce77-3{list-style-type:none}ul.lst-kix_21m4sv2kce77-0{list-style-type:none}ul.lst-kix_21m4sv2kce77-6{list-style-type:none}ul.lst-kix_21m4sv2kce77-5{list-style-type:none}ul.lst-kix_21m4sv2kce77-8{list-style-type:none}ul.lst-kix_21m4sv2kce77-7{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c23{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:41.2pt;border-top-color:#000000;border-bottom-style:solid}.c24{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:241.5pt;border-top-color:#000000;border-bottom-style:solid}.c9{-webkit-text-decoration-skip:none;color:#1155cc;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Arial";font-style:normal}.c1{background-color:#ffffff;color:#24292e;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Consolas";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c18{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c10{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c31{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;text-align:left}.c8{background-color:#ffffff;font-size:9pt;font-family:"Consolas";color:#24292e;font-weight:400}.c2{background-color:#ffffff;font-size:9pt;font-family:"Consolas";color:#005cc5;font-weight:400}.c4{background-color:#ffffff;font-size:9pt;font-family:"Consolas";color:#d73a49;font-weight:400}.c19{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;text-align:left}.c32{background-color:#ffffff;color:#6a737d;font-weight:400;font-size:9pt;font-family:"Consolas"}.c35{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c5{background-color:#ffffff;font-size:9pt;font-family:"Consolas";color:#6f42c1;font-weight:400}.c16{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c36{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c20{color:#000000;font-weight:400;font-size:20pt;font-family:"Arial"}.c27{color:#434343;font-weight:400;font-size:14pt;font-family:"Arial"}.c26{color:#000000;font-weight:400;font-size:16pt;font-family:"Arial"}.c13{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c21{color:#000000;font-weight:700;font-size:20pt;font-family:"Arial"}.c17{color:#000000;font-weight:400;font-size:26pt;font-family:"Arial"}.c33{margin-left:89.2pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c37{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c7{text-decoration:none;vertical-align:baseline;font-style:normal}.c6{font-weight:400;font-family:"Courier New"}.c30{padding:0;margin:0}.c11{color:inherit;text-decoration:inherit}.c25{margin-left:36pt;text-indent:36pt}.c34{margin-left:72pt;text-indent:36pt}.c22{vertical-align:super}.c12{font-style:italic}.c14{vertical-align:sub}.c15{height:11pt}.c29{background-color:#b7b7b7}.c28{height:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body style="background-color: black; padding-top: 10px;"><div style="margin-left: auto; margin-right: auto;" class="c37"><p class="c0"><span class="c3">Michael Henning (mch258)</span></p><p class="c0"><span class="c3">Max Rademacher (mtr73)</span></p><p class="c0"><span class="c3">Jonathan Plattner (jsp263)</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c31 title" id="h.lyyituzi8twd"><span class="c17 c7">ECE 5760 Final Project:</span></p><p class="c31 title" id="h.lpf1lbx1hmld"><span class="c7 c17">Interactive Mandelbrot Viewer</span></p><h1 class="c16" id="h.lmasij2tppkp"><span class="c20 c7">Introduction</span></h1><p class="c0"><span class="c3">The internet contains many videos. While these videos come in many shapes and sizes, there is one category of them which entertains more than any other; one category that is truly the pinnacle of western culture: mandelbrot set zoom videos.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Yes, that&#39;s right. Youtube is full of videos zooming in on the mandelbrot set. As majestic as all of these zooms are, after watching them for every day of our lives so far, we eventually came to question their dominance. Wouldn&#39;t it be better to be able to control what part of the mandelbrot set we were viewing? Wouldn&#39;t it be nice to have control over our own destiny?</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">We set out on the most important journey of our lives. We spent many moons, in lab, seeking a better way to view the mandelbrot set. Finally, we emerged with a solution.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>And now, you can benefit from the fruit of our labor with the ECE 5760 Real-TIme Mandelbrot Set Renderer</span><span class="c22">TM</span><span>! This amazing improvement on former mandelbrot rendering technology uses an FPGA to accelerate rendering to </span><span class="c12">incredible</span><span class="c3">&nbsp;speeds. This, in combination with custom-developed mandelbrot viewing software, allows interactive exploration of the mandelbrot set to a degree that humankind has never seen before.</span></p><h1 class="c16" id="h.a62t09oxe293"><span class="c20 c7">Design and Testing Methods</span></h1><h3 class="c19" id="h.uepj1qkzig49"><span class="c27 c7">High Level Design</span></h3><p class="c0"><span class="c3">The mandelbrot set is the set of points in the complex plane that converge in the following series, where c is the original point in the complex plane.</span></p><p class="c18"><img src="images/image1.png"></p><p class="c0"><span class="c3">It has been proven that when the magnitude of z is larger than 2, the series will diverge. Thus, the set is computed by iterating through the z series of each pixel and stopping when either the divergence criterion is met, or when some iteration limit is met. If the iteration limit is met, the pixel is considered to be in the set. </span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Our goal with this system was to allow for real-time exploration of the mandelbrot set at relatively deep zoom levels, and a number of design decisions were made in service of this goal. We realized that in order to achieve deep zoom levels, we needed the ability to cache the images of the mandelbrot set that we generate, because the calculations of deep zooms cannot be done at an interactive rate of 60 fps. We therefore have our solvers output tiles, which are 64x64 pixel images of the mandelbrot set that are generated at discrete locations and zoom levels and form the basic unit of caching and parallelism in our design.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">At a high level, the system works as follows: The user interacts with a program running on a standard desktop or laptop computer, which allows them to control the viewport of what parts of the mandelbrot set they are exploring. This program then sends requests for tiles over the network to a tile server, which is running on linux on a DE1-Soc board. The DE1-Soc has an integrated FPGA, which is then used to accelerate solving the tiles. Once tiles are solved, the tile server collects the results and sends them back to the user&rsquo;s computer, which displays the tiles on the screen.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">In order to support deep zooms of the mandelbrot set, we had to make sure that none of the components of our design had significant limitations on the precision of the numbers used. This means that the viewer program had to maintain viewport coordinates as arbitrary precision numbers, the request interfaces had to support variable length requests, and the solvers had to be written with arbitrary precision arithmetic support.</span></p><h3 class="c19" id="h.hos7p3fl928u"><span class="c7 c27">Hardware</span></h3><p class="c0"><span>Because one of the main goals of the project was to be able to zoom in infinitely, we needed to be able to compute the z series with arbitrary precision. We chose to represent the arbitrary precision numbers in 27 bit chunks called limbs. The first limb or the number is the integral part and all of the following limbs make up the decimal part. Addition in this format is fairly simple - add all of the corresponding limbs of the two numbers together, keeping track of a carry. Multiplication, however, is a harder problem. The algorithm we chose is the simplest (grade school) algorithm and has an O(n</span><span class="c22">2</span><span class="c3">) running time. Take each pair of limbs in the two numbers and multiply them together. Then add the result into the appropriate limb in the result and propagate the carry. The index of that limb is computed by adding the indices of the multiplicand limbs, where the most significant limb is at index zero.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>A single solver on the FPGA is can solve one tile at a time. It does so by solving each pixel in series and then moving to the next pixel in the tile and solving it. The pixel is computed by solving an iteration of the z series, checking for divergence, and then repeating if it did not diverge. To compute a single iteration of the series, the solver evaluates both the real and imaginary components of z</span><span class="c14">n+1</span><span>&nbsp;one limb at a time. The formulas of z</span><span class="c14">real</span><span>&nbsp;and z</span><span class="c14">imag</span><span class="c3">&nbsp;are given as follows.</span></p><p class="c18"><img src="images/image2.png"></p><p class="c18"><img src="images/image3.png"></p><p class="c0"><span>To compute a limb of z</span><span class="c14">n+1</span><span>, the solver iterates through all of the pairs of limbs in z</span><span class="c14">n</span><span>&nbsp;whose indices sum to the index of the limb currently being computed. For each pair of limbs, it first loads them from the two M10K blocks dedicated to storing the real and imaginary components of z. It also loads the real and imaginary limbs of c from two different M10K blocks. The components of z are then multiplied together to compute the products: z</span><span class="c14">real</span><span>z</span><span class="c14">imag</span><span>, z</span><span class="c22">2</span><span class="c14">real</span><span>, and z</span><span class="c22">2</span><span class="c14">imag</span><span>. The z</span><span class="c14">real</span><span>z</span><span class="c14">imag</span><span>&nbsp;product is computed once a cycle with a DSP multiplier. The squared products require multiple limbs from the same number, but we can only load one limb per cycle. Thus, the second multiplier alternates computing z</span><span class="c22">2</span><span class="c14">real</span><span>&nbsp;and z</span><span class="c22">2</span><span class="c14">imag</span><span>&nbsp;while the values for the product not being computed are queued up. As the three products are computed, they are folded into an accumulator which keeps track of the values for the components of z</span><span class="c14">n+1</span><span>&nbsp;currently being calculated. For the real component, this is done by adding in either the result of the squaring multiplier, or by adding in its negation, depending on whether the multiplier had just computed the square of the real or imaginary limbs. For the imaginary component, folding into the accumulator is done by left-shifting the result of the other multiplier by one to multiply by two and then adding into the accumulator. Once the two components of the limbs of z</span><span class="c14">n+1</span><span>&nbsp;are fully computed, the values of the accumulators are saved into the same M10K blocks that originally stored the components of z</span><span class="c14">n</span><span class="c3">. The accumulators are reset and initialized with the carry from the previous limb (this is done by signed right-shifting the previous accumulator value) plus the value of the appropriate c limb.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>The solver was designed with a pipeline architecture in order to reduce the critical path. It consists of six stages. First, the control stage (C) is a large state machine which determines all of the necessary control signals needed to get the rest of the solver to perform the computation. Then the read stage (R) reads the appropriate real and imaginary limbs from z and c from the four M10K blocks used to store them. Next, the absolute value stage (A) ensures that numbers being sent to the multipliers are positive. This is necessary because the multiplication algorithm does not work if any of the multiplicands are negative. The multiplication stage (M) consists of the two multipliers - one which computes z</span><span class="c14">real</span><span>z</span><span class="c14">imag</span><span>&nbsp;and another that alternates squaring the components. In the execute stage (X), the products are folded into the accumulators. Finally, the limbs of z</span><span class="c14">n+1</span><span class="c3">&nbsp;are written back into ram in the write stage (W).</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>The control stage keeps track of an iteration count and terminates this process, so the solver can move to the next pixel, if the iteration limit is reach or if the series diverges. Divergence is computed by keeping a divergence accumulator which stores the value of z</span><span class="c22">2</span><span class="c14">real</span><span>&nbsp;+ z</span><span class="c22">2</span><span class="c14">imag</span><span class="c3">. If the value of this accumulator is larger than 4 when the last limb is done being calculated, then the series has diverged and the solver can move to the next pixel.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 237.33px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 237.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c19" id="h.w3r99m83igft"><span class="c27 c7">Software</span></h3><p class="c0"><span class="c3">The software for this project was split into the server- and client-side code. The server runs on the HPS does the work of solving the mandelbrot equation and sending the resulting iteration data to the client. The client runs on a laptop and is responsible for coloring and rendering iteration data, as well as handling user input. This separation allowed us to move the computational load of rendering from the HPS/FPGA to a separate laptop, improving solver performance and also allowing higher resolutions (we used 1600x900, but 1080p is probably possible). The client can also connect to multiple servers, so running two or more FPGA solvers allows for more performance improvements.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">The mandelbrot solver from lab 3 would solve the mandelbrot equation for every pixel, every frame. This was inefficient because often each pixel is regenerated hundreds of times when it could instead have been cached and reused. One of the primary optimizations we implemented was storing this generated data and reusing it each frame. Rather than solving a single pixel, the FPGA solves one &ldquo;tile&rdquo; at a time, where a tile is a 64x64 square of pixels. This tile data was then stored in a tile cache, and then tiles were rendered to the screen multiple times without being recomputed.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>A tile is uniquely identified by a 4-tuple of integers (</span><span class="c12">x</span><span>, </span><span class="c12">y</span><span>, </span><span class="c12">z</span><span>, </span><span class="c12">i</span><span>). The </span><span class="c12">i</span><span>&nbsp;value of a tile specifies the iteration limit. The </span><span class="c12">z</span><span>&nbsp;value represents the zoom level of the tile, where tiles with </span><span class="c12">z</span><span>=0 have a width and height of 1. Increasing </span><span class="c12">z</span><span>&nbsp;by 1 corresponds to decreasing tile size by a factor of 2. The values </span><span class="c12">x</span><span>&nbsp;and </span><span class="c12">y</span><span>&nbsp;specify a tile&rsquo;s location, where a tile with </span><span class="c12">x</span><span>=0, </span><span class="c12">y</span><span>=0 has its bottom left corner at the point (0, 0). A tile with </span><span class="c12">x</span><span>=1, </span><span class="c12">y</span><span>=0 is one tile length to the right of (0, 0). Thus, the point in space specified by </span><span class="c12">x</span><span>&nbsp;and</span><span>&nbsp;</span><span class="c12">y</span><span>&nbsp;is dependent on the value of </span><span class="c12">z</span><span>. As </span><span class="c12">z</span><span>&nbsp;increases by 1, </span><span class="c12">x</span><span>&nbsp;and </span><span class="c12">y</span><span>&nbsp;will increase by a factor of 2. Because of this, </span><span class="c12">x</span><span>&nbsp;and </span><span class="c12">y</span><span>&nbsp;were represented as multiple-precision integers because they overflow a 64-bit long integer when </span><span class="c12">z</span><span class="c3">&nbsp;is greater than about 64. These 4 values are stored in the TileHeader class.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">The renderer has a viewport that is defined by a complex origin and a complex screen size. With this information the renderer can generate a set of TileHeaders that will span the viewport. The renderer sorts these TileHeaders based on a priority function, so that the tiles in the center of the viewport are of high priority and are generated first. In order of priority, each TileHeader is serialized and sent to the server as a tile request.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">The server receives tile requests from the client and deserializes them into TileHeaders. It then converts each TileHeader into the format used by the FPGA. The x and y values, which are multiple-precision integers, are converted into a format understood by the FPGA, multiple-precision values with 27 bit limbs. This data (plus the iteration limit) is sent to the FPGA, which then solves the tile and writes it back into HPS memory. Once the server has a solved tile, it sends the serialized data back to the client over ethernet.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">When the client receives a tile, it stores it in a tile cache. When the renderer requests the tile on the next frame, it checks the tile cache before sending a request to the server. Because of this, each tile is only generated once and is then reused whenever it is requested again. The exception is that when the tile cache is full, the least recently used tiles are evicted and if they are requested again they must be regenerated.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Tiles in the tile cache contain only iteration data, but do not have any color information. To generate color data, each color channel is a function of the sine of the iteration count with differing periods and phase shifts for each color. The periods were chosen to be rational numbers with a large least common multiple (LCM), so that the color cycles will not repeat until approximately LCM iterations. In addition to red, green, and blue channels, there is also a luminance channel that controls the overall color level of the pixel (0 luminance is black, 1 is white), with a shorter period than the color channels. This causes the colors to cycle through black-&gt;color-&gt;white-&gt;color repeatedly, where each color is different from the last. This resulted in a visually pleasing coloring of the set that retains detail even at extremely high iteration counts.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Before a tile is drawn to the screen, each pixel&rsquo;s iteration count is mapped to an RGB value using the above color mapping, and these colored pixels are made into a renderable texture. Because this coloring is too expensive to do every frame (and also because texture creation is expensive), these colored textures are stored in a texture cache. The texture cache is much smaller than the tile data cache because color generation is much less expensive than tile generation. Generally, good performance is achieved as long as the texture cache is large enough to fit one whole viewport at a time.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Once tiles are generated and colored, the renderer draws them to the screen. If a tile is missing from the cache (i.e. hasn&rsquo;t been sent back from the server yet), the renderer will try to display a lower resolution (lower z-level) tile in the same position, up to a limit of 5 z-levels below the current resolution. This results in much smoother zooming because lower resolution tiles can be rendered while the higher resolution tiles are computed.</span></p><h3 class="c19" id="h.xmt4qm5l8iqv"><span class="c27 c7">Bus Design</span></h3><p class="c0"><span class="c3">The communication between the FPGA and the hard processor system happens over a memory-mapped AXI bus. Requests for tiles are placed into a FIFO on the FPGA, and solved tile data is written out into external SDRAM memory.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">When the hard processor system has a request to submit, it converts the request to a format that was designed for easy decoding on the FPGA. This format, in short, consists of a series of 32-bit values, of which the upper 3 bits are used to specify the type of the current value (ie, whether it is an output address, the zoom level, or a limb of the complex number representing the tile&rsquo;s upper lefthand corner), and the lower 29 bits are used to encode the value itself.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">This request is then sent over the AXI bus into a FIFO located on the FPGA. A request distributor then pulls the message off of the FIFO using the avalon streaming interface, and either sends it, one word at a time, to an unoccupied tile solver or waits if they are all occupied. This design allows tile solvers to immediately receive a new request once they become free, meaning that we have high solver utilization. At the same time, the latency of a tile being solved is minimized because there is only a single queue of tiles across all solvers and distribution happens at the last possible moment. This is superior to schemes where, for example, each solver has its own queue and work distribution happens on the HPS because in such a scheme, a tile might get stuck waiting in a queue behind a particularly difficult tile while other solvers are free.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">As the solvers solve pixels of the output tile, they write the results to SDRAM. We then have arbitration logic which collects results from any solvers which are ready to write. The arbitration is quite simple, and just chooses the solver with the lowest id that has a result ready.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Note that the FPGA has no special mechanism to notify the HPS that a result has been computed. The HPS determines that a tile has been completed by writing a sentinel value, -2, &nbsp;into the last pixel of an output tile. Since this is not a legal pixel solution value, the HPS is able to poll the value at this last pixel, and determine that once -2 has been overwritten with another value, the tile solving is complete.</span></p><h3 class="c19" id="h.f5yipxq25odo"><span class="c27 c7">Testing Methods</span></h3><p class="c0"><span class="c3">Each of the verilog modules in our design has at least one individual test bench which allows us to test it in simulation. This is important because the compile-test cycles can be quite long when compiling for the actual FPGA. In addition to the per-module tests, there is also a larger integration test which runs all of the components together, starting at the request distributor and ending with the write arbitrator. This test allows us to solve tiles in simulation using multiple solvers, and even outputs the results in a format that can be displayed with a special python script. This allows us to manually verify that the images of the mandelbrot set are being generated correctly.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">In addition to the FPGA solver, we also developed a solver in C++ that can run on a standard desktop computer. The benefits of this were twofold: first, it allowed us to test our algorithms and verify them before implementing them in difficult-to-write verilog, and second, it allowed us to test the C++ components of our system conveniently without access to specialized hardware.</span></p><h1 class="c16" id="h.dyr834ulrdos"><span class="c7 c20">Documentation</span></h1><h2 class="c35" id="h.btd66lll6vhp"><span class="c26 c7">Hardware</span></h2><p class="c0"><span class="c4">module</span><span class="c8">&nbsp;</span><span class="c5">solver</span><span class="c1">&nbsp;#(</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">parameter</span><span class="c8">&nbsp;LIMB_INDEX_BITS &nbsp; </span><span class="c4">=</span><span class="c8">&nbsp;</span><span class="c2">6</span><span class="c1">,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">parameter</span><span class="c8">&nbsp;LIMB_SIZE_BITS &nbsp; &nbsp;</span><span class="c4">=</span><span class="c8">&nbsp;</span><span class="c2">27</span><span class="c1">,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">parameter</span><span class="c8">&nbsp;DIVERGENCE_RADIUS </span><span class="c4">=</span><span class="c8">&nbsp;</span><span class="c2 c7">4</span></p><p class="c0"><span class="c1">) (</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c1">&nbsp; clock, reset,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wr_real_en,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wr_imag_en,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c8">&nbsp;[LIMB_INDEX_BITS</span><span class="c4">-</span><span class="c2">1</span><span class="c8">:</span><span class="c2">0</span><span class="c1">] wr_index,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c8">&nbsp;[LIMB_SIZE_BITS</span><span class="c4">-</span><span class="c2">1</span><span class="c8">:</span><span class="c2">0</span><span class="c1">] &nbsp;real_data,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c8">&nbsp;[LIMB_SIZE_BITS</span><span class="c4">-</span><span class="c2">1</span><span class="c8">:</span><span class="c2">0</span><span class="c1">] &nbsp;imag_data,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wr_num_limbs_en,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c8">&nbsp;[LIMB_INDEX_BITS</span><span class="c4">-</span><span class="c2">1</span><span class="c8">:</span><span class="c2">0</span><span class="c1">] num_limbs_data,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wr_iter_lim_en,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c8">&nbsp;[</span><span class="c2">15</span><span class="c8">:</span><span class="c2">0</span><span class="c1">] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;iter_lim_data,</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">input</span><span class="c1">&nbsp;start,</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">output</span><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out_ready,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">output</span><span class="c8">&nbsp;[</span><span class="c2">15</span><span class="c8">:</span><span class="c2">0</span><span class="c1">] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterations</span></p><p class="c0"><span class="c1">);</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>The </span><span class="c6">solver</span><span>&nbsp;can compute a single pixel in the mandelbrot set. It has two ram modules to store the real and imaginary components of the pixel it is solving. You must first load in the c value you would like it to compute, then you can instruct it to begin solving by pulsing the start </span><span class="c6">signal</span><span class="c3">.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c4">module</span><span class="c8">&nbsp;</span><span class="c5">tile_solver_legit</span><span class="c8">&nbsp;</span><span class="c4">#</span><span class="c1">(</span></p><p class="c0"><span class="c4">&nbsp; &nbsp;parameter</span><span class="c8">&nbsp;</span><span class="c2">TILE_WIDTH_BITS</span><span class="c8">&nbsp; &nbsp;</span><span class="c4">=</span><span class="c8">&nbsp;</span><span class="c2">5</span><span class="c1">,</span></p><p class="c0"><span class="c4">&nbsp; &nbsp;parameter</span><span class="c8">&nbsp;</span><span class="c2">LIMB_INDEX_BITS</span><span class="c8">&nbsp; &nbsp;</span><span class="c4">=</span><span class="c8">&nbsp;</span><span class="c2">6</span><span class="c1">,</span></p><p class="c0"><span class="c4">&nbsp; &nbsp;parameter</span><span class="c8">&nbsp;</span><span class="c2">LIMB_SIZE_BITS</span><span class="c8">&nbsp; &nbsp; </span><span class="c4">=</span><span class="c8">&nbsp;</span><span class="c2">27</span><span class="c1">,</span></p><p class="c0"><span class="c4">&nbsp; &nbsp;parameter</span><span class="c8">&nbsp;</span><span class="c2">DIVERGENCE_RADIUS</span><span class="c8">&nbsp;</span><span class="c4">=</span><span class="c8">&nbsp;</span><span class="c2 c7">4</span></p><p class="c0"><span class="c1">) (</span></p><p class="c0"><span class="c2">&nbsp; &nbsp;input</span><span class="c1">&nbsp;clock,</span></p><p class="c0"><span class="c2">&nbsp; &nbsp;input</span><span class="c1">&nbsp;reset,</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c2">&nbsp; &nbsp;input</span><span class="c8">&nbsp;[</span><span class="c2">31</span><span class="c4">:</span><span class="c2">0</span><span class="c1">] in_data,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">input</span><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; in_valid,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">output</span><span class="c8">&nbsp;</span><span class="c4">reg</span><span class="c1">&nbsp; &nbsp;in_ready,</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c7 c32">// Assert in_end_of_stream after the input packet has been provided.</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c32 c7">// The next cycle must have in_valid = 0 (no data moves)</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">input</span><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; in_end_of_stream,</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">output</span><span class="c8">&nbsp;</span><span class="c4">reg</span><span class="c8">&nbsp;[</span><span class="c2">31</span><span class="c4">:</span><span class="c2">0</span><span class="c1">] out_addr,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">output</span><span class="c8">&nbsp;</span><span class="c4">reg</span><span class="c8">&nbsp;[</span><span class="c2">15</span><span class="c4">:</span><span class="c2">0</span><span class="c1">] out_data,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">output</span><span class="c8">&nbsp;</span><span class="c4">reg</span><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; out_valid,</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">input</span><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out_ready</span></p><p class="c0"><span class="c1">);</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span>A </span><span class="c6">tile_solver_legit</span><span>&nbsp;knows how to communicate with the HPS and how to use its </span><span class="c6">solver</span><span>&nbsp;to solve each pixel in the tile it&rsquo;s working on.</span></p><h2 class="c35" id="h.hjzv58av780l"><span class="c7 c26">Software</span></h2><p class="c0"><span class="c4">class</span><span class="c8">&nbsp;</span><span class="c5">complex</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c4">p</span><span class="c4 c7">ublic:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;mpf_class real;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;mpf_class imag;</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c5">complex</span><span class="c1">(mpf_class real_, mpf_class imag_);</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">bool</span><span class="c8">&nbsp;</span><span class="c4">operator</span><span class="c8">==(</span><span class="c4">const</span><span class="c8">&nbsp;complex&amp; other) </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;std::vector&lt;</span><span class="c2">uint32_t</span><span class="c8">&gt; </span><span class="c5">get_real_limbs</span><span class="c8">(</span><span class="c4">int</span><span class="c8">&nbsp;limb_bits) </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;std::vector&lt;</span><span class="c2">uint32_t</span><span class="c8">&gt; </span><span class="c5">get_imag_limbs</span><span class="c8">(</span><span class="c4">int</span><span class="c8">&nbsp;limb_bits) </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">The complex class represents a point in the complex plain. It uses mpf_class from the GMP Multiple Precision Library to represent floating point values with arbitrary precision.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c4">class</span><span class="c8">&nbsp;</span><span class="c5">TileHeader</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c4">p</span><span class="c4 c7">ublic:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;mpz_class x;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;mpz_class y;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">int32_t</span><span class="c1">&nbsp;z;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">int16_t</span><span class="c1">&nbsp;iter_lim;</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c5">TileHeader</span><span class="c8">(mpz_class x_in, mpz_class y_in, </span><span class="c2">uint32_t</span><span class="c8">&nbsp;z_in, </span><span class="c2">int16_t</span><span class="c1">&nbsp;iter_lim)</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;complex </span><span class="c5">getOrigin</span><span class="c8">() </span><span class="c4">const</span><span class="c8">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">double</span><span class="c8">&nbsp;</span><span class="c5">getSize</span><span class="c8">() </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">bool</span><span class="c8">&nbsp;</span><span class="c4">operator</span><span class="c8">==(</span><span class="c4">const</span><span class="c8">&nbsp;TileHeader&amp; other) </span><span class="c4">cons</span><span class="c4">t</span><span class="c1">;</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">struct</span><span class="c8">&nbsp;</span><span class="c5">Hasher</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp;std::</span><span class="c2">size_t</span><span class="c8">&nbsp;</span><span class="c5">operator</span><span class="c8">()(</span><span class="c4">const</span><span class="c8">&nbsp;std::shared_ptr&lt;TileHeader&gt;&amp; header) </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;};</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">struct</span><span class="c8">&nbsp;</span><span class="c5">Comparator</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c4">bool</span><span class="c8">&nbsp;</span><span class="c5">operator</span><span class="c8">()(</span><span class="c4">const</span><span class="c1">&nbsp;std::shared_ptr&lt;TileHeader&gt;&amp; a,</span></p><p class="c0 c34"><span class="c4">const</span><span class="c8">&nbsp;std::shared_ptr&lt;TileHeader&gt;&amp; b) </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;};</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;std::vector&lt;</span><span class="c2">uint8_t</span><span class="c8">&gt; </span><span class="c5">serialize</span><span class="c1">();</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">static</span><span class="c8">&nbsp;std::unique_ptr&lt;TileHeader&gt; </span><span class="c5">deserialize</span><span class="c8">(</span><span class="c4">const</span><span class="c8">&nbsp;std::vector&lt;</span><span class="c2">uint8_t</span><span class="c1">&gt;&amp; data);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;std::string </span><span class="c5">get_str</span><span class="c1">();</span></p><p class="c0"><span class="c8">};</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">The TileHeader class contains the (x, y, z, i) data necessary to uniquely identify a tile. It uses mpz_class from the GMP Multiple Precision Library to represent integers of arbitrary size. TileHeaders are used to specify tile requests, so they must be serializable in order to passed back and forth between client and server. TileHeaders are also used as keys into the tile cache and the texture cache, so they implement a hash function and a comparator.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c4">class</span><span class="c8">&nbsp;</span><span class="c5">Tile</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c4">p</span><span class="c4 c7">ublic:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c5">Tile</span><span class="c1">(std::shared_ptr&lt;TileHeader&gt; header);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c5">Tile</span><span class="c8">(std::shared_ptr&lt;TileHeader&gt; header, std::vector&lt;</span><span class="c2">uint16_t</span><span class="c1">&gt; data);</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp;complex </span><span class="c5">getOrigin</span><span class="c8">() </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">double</span><span class="c8">&nbsp;</span><span class="c5">getSize</span><span class="c8">() </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">bool</span><span class="c8">&nbsp;</span><span class="c5">hasData</span><span class="c8">() </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;std::shared_ptr&lt;TileHeader&gt; </span><span class="c5">getHeader</span><span class="c8">() </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;std::vector&lt;</span><span class="c2">uint16_t</span><span class="c8">&gt; </span><span class="c5">getData</span><span class="c8">() </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">uint16_t</span><span class="c8">&nbsp;</span><span class="c5">getPoint</span><span class="c8">(</span><span class="c4">int</span><span class="c8">&nbsp;x, </span><span class="c4">int</span><span class="c8">&nbsp;y) </span><span class="c4">const</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">setPoint</span><span class="c8">(</span><span class="c4">int</span><span class="c8">&nbsp;x, </span><span class="c4">int</span><span class="c8">&nbsp;y, </span><span class="c2">uint16_t</span><span class="c1">&nbsp;value);</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">A tile consists of a TileHeader, a vector of iteration data, and a flag that specifies whether the iteration data is valid.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c4">class</span><span class="c8">&nbsp;</span><span class="c5">TileManager</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c4">p</span><span class="c4 c7">ublic:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c5">TileManager</span><span class="c8">(std::vector&lt;std::tuple&lt;std::string, </span><span class="c4">int</span><span class="c1">&gt;&gt; ip_addrs,</span></p><p class="c0 c25"><span class="c4">int</span><span class="c8">&nbsp;cache_size, </span><span class="c4">int</span><span class="c8">&nbsp;request_depth = </span><span class="c2">30</span><span class="c1">);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;std::shared_ptr&lt;Tile&gt; </span><span class="c5">requestTile</span><span class="c8">(std::shared_ptr&lt;TileHeader&gt; header, </span><span class="c4">int</span><span class="c1">&nbsp;depth);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;std::set&lt;std::shared_ptr&lt;Tile&gt;&gt; </span><span class="c5">loadViewport</span><span class="c1">(Viewport viewport);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c2">int16_t</span><span class="c8">&nbsp;</span><span class="c5">getIterations</span><span class="c1">();</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">setIterations</span><span class="c8">(</span><span class="c2">int16_t</span><span class="c1">&nbsp;iterations);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">clearRequests</span><span class="c1">();</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c3">The TileManager is responsible for giving the Renderer all the tiles it needs to draw the current viewport. When the Renderer calls TileManager::loadViewport(), the TileManger builds a set of tiles that will span the viewport and then requests each of those tiles from the server. The TileManager has a TileClient for each server that it is connected to, which it uses to request and receive tiles from the server. The TileManager also manages the tile cache.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c4">class</span><span class="c8">&nbsp;</span><span class="c5">Renderer</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c4">p</span><span class="c4">ublic:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">setColorPhases</span><span class="c8">(</span><span class="c4">float</span><span class="c8">&nbsp;r, </span><span class="c4">float</span><span class="c8">&nbsp;g, </span><span class="c4">float</span><span class="c8">&nbsp;b, </span><span class="c4">float</span><span class="c1">&nbsp;l);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">setColorPeriods</span><span class="c8">(</span><span class="c4">float</span><span class="c8">&nbsp;r, </span><span class="c4">float</span><span class="c8">&nbsp;g, </span><span class="c4">float</span><span class="c8">&nbsp;b, </span><span class="c4">float</span><span class="c1">&nbsp;l);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">randomizeColors</span><span class="c1">();</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">scaleColors</span><span class="c8">(</span><span class="c4">float</span><span class="c1">&nbsp;s);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">render</span><span class="c8">(</span><span class="c4">const</span><span class="c1">&nbsp;std::set&lt;std::shared_ptr&lt;Tile&gt;&gt;&amp; tiles,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Viewport viewport,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SDL_Renderer* sdl_renderer);</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">The Renderer takes a set of tiles, colors them, and draws them to the screen at the appropriate scale and location. Because tile coloring is expensive, the Renderer also manages a texture cache to avoid coloring the same tile multiple times.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c4">class</span><span class="c8">&nbsp;</span><span class="c5">TileClient</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c4">p</span><span class="c4 c7">ublic:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c5">TileClient</span><span class="c8">(std::string ip_addr, </span><span class="c4">int</span><span class="c1">&nbsp;port);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">init</span><span class="c1">();</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">requestTile</span><span class="c1">(std::shared_ptr&lt;TileHeader&gt; header);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;std::unique_ptr&lt;Tile&gt; </span><span class="c5">receiveTile</span><span class="c1">();</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>The TileClient manages the state necessary for communicating with a server. The TileClient opens a socket connection with a server and can send and receive packets of serialized data. It sends tile headers when they are requested, and receives tiles</span><span>&nbsp;when the server generates them.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c4">class</span><span class="c8">&nbsp;</span><span class="c5">TileServer</span><span class="c8">&nbsp;{</span></p><p class="c0"><span class="c4">p</span><span class="c4 c7">ublic:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c5">TileServer</span><span class="c8">(</span><span class="c4">int</span><span class="c1">&nbsp;port);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">init</span><span class="c1">();</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">int</span><span class="c8">&nbsp;</span><span class="c5">awaitConnection</span><span class="c1">();</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">serveForever</span><span class="c1">();</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">The TileServer runs on the HPS and facilitates communication with one or more TileClients. It listens for tile requests, adds them to a queue to be processed by the solver, and then sends the data back to the client.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c4">class</span><span class="c8">&nbsp;</span><span class="c5">Solver</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c4">p</span><span class="c4 c7">ublic:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">typedef</span><span class="c8">&nbsp;std::unique_ptr&lt;</span><span class="c4">volatile</span><span class="c8">&nbsp;</span><span class="c2">int16_t</span><span class="c8">[], std::function&lt;</span><span class="c4">void</span><span class="c8">(</span><span class="c4">volatile</span><span class="c8">&nbsp;</span><span class="c2">int16_t</span><span class="c1">*)&gt;&gt; data;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">virtual</span><span class="c8">&nbsp;</span><span class="c5">~Solver</span><span class="c8">() = </span><span class="c2">0</span><span class="c1">;</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">sumbit</span><span class="c1">(std::shared_ptr&lt;TileHeader&gt; header);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;Solver::data </span><span class="c5">retrieve</span><span class="c1">(std::shared_ptr&lt;TileHeader&gt; header);</span></p><p class="c0 c15"><span class="c1"></span></p><p class="c0"><span class="c4">p</span><span class="c4 c7">rotected:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">freeListAppend</span><span class="c8">(</span><span class="c4">volatile</span><span class="c8">&nbsp;</span><span class="c2">int16_t</span><span class="c1">* data);</span></p><p class="c0"><span class="c8">&nbsp; &nbsp;</span><span class="c4">virtual</span><span class="c8">&nbsp;</span><span class="c4">void</span><span class="c8">&nbsp;</span><span class="c5">queueTile</span><span class="c1">(std::shared_ptr&lt;TileHeader&gt; header) = 0;</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>The solver is an abstract class which forms the interface for something that can solve tiles. The two implementations we have are the CPUSolver which can be run entirely on a computer, and the FPGASolver which communicates with the FPGA, where the actual tile solving is done. Requests can be submitted to the solver and then later the tile data can be retrieved from the solver. The </span><span class="c6">submit</span><span>&nbsp;function is non blocking and simply allocates space for the solve data and then calls </span><span class="c6">queueTile</span><span>&nbsp;on its implementing class. The </span><span class="c6">retrieve</span><span>&nbsp;function is also non blocking and returns nullptr if the tile is not yet available. When the solver is instantiated, it allocates all the space it will need for all of the potential tile requests it can handle at once. In the case of the CPU solver, this is done on the heap, and in the case of the FPGA solver, this is done in SRAM. Once the tile data is no longer needed by whoever retrieved it, its destructor calls </span><span class="c6">freeListAppend</span><span>&nbsp;to put the tile solver data slot back on a freelist which the submit function can later allocate to.</span></p><h1 class="c16" id="h.vtw6ynouhjit"><span class="c20 c7">Results</span></h1><p class="c0"><span class="c3">The solver we created was quite fast. As one point of comparison, it took 0.571 seconds to render the initial viewport on a single FPGA at 128 iterations, as compared to 10.14 seconds on a quad core Intel Core i7-4700HQ, which is a improvement of over 17x. Similarly, to generate the first image below from scratch, at zoom level 200 and an iteration limit of 10,000, took 858.3 seconds on the Core i7, and 27.49 seconds on a single FPGA, which is a speedup of over 31x.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">We were able to fit 29 solvers on the FPGA, running at a frequency of 100 MHz. Interestingly, the bottleneck that we ran into that prevented us from instantiating more solvers was the number of logic units on the FPGA. This was contrary to our expectation, which was that the bottleneck would be the number of DSP units available. The final design used 29897 out of the 37070 available ALMs (93%). A single solver module takes ~960 ALMs, with the following breakdown:</span></p><p class="c0 c15"><span class="c3"></span></p><a id="t.72a36ee385730d826a7712d9bcb4a6f0bb25d5ce"></a><a id="t.0"></a><table class="c33"><tbody><tr class="c28"><td class="c24 c29" colspan="1" rowspan="1"><p class="c13"><span class="c3">Module</span></p></td><td class="c23 c29" colspan="1" rowspan="1"><p class="c13"><span class="c3">ALMs</span></p></td></tr><tr class="c28"><td class="c24" colspan="1" rowspan="1"><p class="c13"><span class="c3">Tile Iteration / Bitstream decoding</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c13"><span class="c3">175</span></p></td></tr><tr class="c28"><td class="c24" colspan="1" rowspan="1"><p class="c13"><span class="c3">Pixel Solver</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c13"><span class="c3">791</span></p></td></tr><tr class="c28"><td class="c24" colspan="1" rowspan="1"><ul class="c30 lst-kix_21m4sv2kce77-0 start"><li class="c10"><span class="c3">Control</span></li></ul></td><td class="c23" colspan="1" rowspan="1"><p class="c13"><span class="c3">77</span></p></td></tr><tr class="c28"><td class="c24" colspan="1" rowspan="1"><ul class="c30 lst-kix_az7bl1pfkw68-0 start"><li class="c10"><span class="c3">Data path</span></li></ul></td><td class="c23" colspan="1" rowspan="1"><p class="c13"><span class="c3">714</span></p></td></tr></tbody></table><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Note that the data path is by far the most expensive piece of a solver. This is likely due to the multiple adders and multiplexers it contains.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>We can theoretically zoom to a magnification level of 2</span><span class="c22">1700</span><span>&nbsp;(this is where we run out of solver memory), and have verified in practice that zooms work up until 2</span><span class="c22">260</span><span class="c3">. Tile solving slows down as you zoom in, so at the initial zoom levels, we can solve areas of the mandelbrot set at interactive rates, but at extremely high zoom levels, users might need to wait a few seconds before a region appears.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Below are several images generated by our system.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c16" id="h.agu57g415dp8"><span>Conclusions</span></h1><p class="c0"><span class="c3">In conclusion, this lab was successful.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">If we had more time to improve our design, we could have spent more time working to reduce device utilization to free up resources for more solvers. We could have also worked to increase the clock rate of the solvers. One way to accomplish both of these things would have been to move the accumulators for multiplications into the DSP units available on our FPGA. The multiplications were occurring in the DSP units, but our accumulation step happened in logic elements on the FPGA. Switching to the DSP units would both improve the propagation delays involved because the addition would be happening in dedicated hardware units while simultaneously freeing up device resources. In the end, the solver frequency was limited by the propagation delay in the accumulator as well as between the solvers and the write arbitration logic. For the latter case, we could have inserted more pipeline registers between the solvers and the write arbitrators.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">We also researched ways to improve our solver algorithm. One potential way was writing an epsilon solver, which would have taken advantage of perturbation theory and series approximation to improve performance. The idea is that once the iteration series for one pixel is computed in expensive high precision arithmetic, it can be used to solve nearby pixels with much faster single-precision arithmetic. This is because, rather than computing the iteration series, you can just compute the difference (epsilon) from the high precision reference series, and this epsilon series can be computed in single-precision. According to Wikipedia and other sources, this method can provide anywhere from a 10x to 100x performance increase at high zoom levels. Unfortunately we didn&rsquo;t have time to implement this optimization.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Another thing we considered was including cycle detection, where you can detect early on that if, while solving a pixel, you visit the same z value twice, the point will definitely be in the mandelbrot set. This has the potential to significantly speed up solving tiles which are largely in the set. We actually did implement this improvement, but it unfortunately used so many logic elements that we decided the tradeoff wasn&rsquo;t worth it. As a result, cycle detection wasn&rsquo;t included in our final product. It&rsquo;s still an open problem as to whether cycle detection could be done cheaply enough to make the tradeoff worth it. Both methods of speeding up the solver would be worth evaluating in later designs.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">It&rsquo;s also apparent to us that we could have improved the FPGA/HPS interface in a few ways. One issue with the current write arbitration logic is that when multiple solvers are trying to write to SDRAM, the one with the lowest id wins. This can lead to issues with starvation; suppose that the 10 lowest ID solvers are solving easy tiles. In this case, at least one of them will be ready to write on every cycle and will starve the higher ID solvers from ever making progress. While we haven&rsquo;t measured how often this actually occurs in practice, it would be worthwhile to research using a more intelligent scheme like round-robin for write arbitration. We could also have likely reduced latency a bit if we put in the additional work to use interrupts instead of polling or written into the HPS&rsquo; DDR3 RAM instead of the external SDRAM. Unfortunately, either of those two solutions would have required writing linux kernel drivers, which was outside of the scope of this project.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">We observed that the renderer stutters and has an inconsistent framerate while transitioning to a new zoom level. This is because tile coloring is done on the same thread as rendering, and there can be a significant amount of computation needed to color a whole layer of new tiles. An improvement would be to move coloring to a background thread, which would fix the framerate issues. Another possible solution would be to optimize or hardware accelerate tile coloring, or even move coloring to the FPGA.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Another client-side improvement that we would have liked to have made was to improve the multi-server connection logic. The current implementation uses round robin request allocation, so if one server is slowly solving difficult tiles, it will limit the solve rates of all the other servers. A better solution would be to keep track of how many outstanding tile requests had been sent to each server and always send new requests to the server with the smallest queue.</span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span>Some external libraries and IP were used during the development of this project. The FIFO instantiated on the FPGA, along with the Avalon bus structure and SDRAM controller that we used, were all Altera IP. The C++ code also used the GMP library to store arbitrary precision integers, as well as SDL2 for the display and input handling.</span></p><h1 class="c16" id="h.bnv0of9g77z8"><span class="c20 c7">Work Distribution</span></h1><h3 class="c19" id="h.trlu1nnjv2nl"><span class="c27 c7">Code</span></h3><p class="c0"><span class="c3">Max wrote the single-pixel solvers in verilog and the corresponding arbitrary precision arithmetic. Mike wrote the modules on the FPGA that perform request distribution, request decoding, tile iteration, and write arbitration. Jon wrote the majority of the C++ code, including the HPS tile server and the display client, including coloring and rendering the tiles.</span></p><h3 class="c19" id="h.58b4o3kcimzj"><span class="c27 c7">Report</span></h3><p class="c0"><span class="c3">Max wrote the hardware section. Jon wrote the software section. Mike wrote the bus design section, testing section, and work distribution section. The results and conclusion sections were split evenly.</span></p><hr style="page-break-before:always;display:none;"><p class="c0 c15"><span class="c3"></span></p><h1 class="c16" id="h.d0mfy53ee20y"><span class="c20 c7">Appendix A</span></h1><p class="c0"><span class="c3">The group approves this report for inclusion on the course website.</span></p><p class="c0"><span class="c3">The group approves the video for inclusion on the course website.</span></p><h1 class="c16" id="h.4ztbt26fjfc0"><span class="c20 c7">Appendix B - References</span></h1><p class="c0"><span class="c3">Altera Avalon Bus documentation: </span></p><p class="c0"><span class="c36"><a class="c11" href="../../../../../../../../../https@www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf">https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf</a></span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">Altera FIFO Documentation:</span></p><p class="c0"><span class="c36"><a class="c11" href="../../../../../../../../../www.altera.com/literature/hb/nios2/qts_qii55002.pdf">http://www.altera.com/literature/hb/nios2/qts_qii55002.pdf</a></span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">The GNU MP Bignum Library:</span></p><p class="c0"><span class="c36"><a class="c11" href="../../../../../../../../../https@gmplib.org/default.htm">https://gmplib.org/</a></span></p><p class="c0 c15"><span class="c3"></span></p><p class="c0"><span class="c3">SDL2:</span></p><p class="c0"><span class="c36"><a class="c11" href="../../../../../../../../../https@www.libsdl.org/default.htm">https://www.libsdl.org/</a></span></p><h1 class="c16" id="h.oghr3xx3xudo"><span class="c20 c7">Appendix C - Source Code</span></h1><p class="c0"><span class="c9"><a class="c11" href="code/hardware/request_distributor.sv">code/hardware/request_distributor.sv</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/hardware/multi_tile_solver.sv">code/hardware/multi_tile_solver.sv</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/hardware/write_arbitrator.sv">code/hardware/write_arbitrator.sv</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/hardware/tile_solver_legit.sv">code/hardware/tile_solver_legit.sv</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/hardware/solver.v">code/hardware/solver.v</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/hardware/solver_control.v">code/hardware/solver_control.v</a></span></p><p class="c0"><span class="c36"><a class="c11" href="code/hardware/solver_datapath.v">code/hardware/solver_datapath.v</a></span></p><p class="c0 c15"><span class="c9"><a class="c11" href="code/hardware/solver_datapath.v"></a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/cpu_solver.h">code/software/cpu_solver.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/fpga_solver.cpp">code/software/fpga_solver.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/fpga_solver.h">code/software/fpga_solver.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/main.cpp">code/software/main.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/mult_notes.txt">code/software/mult_notes.txt</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/sdl_input_controller.cpp">code/software/sdl_input_controller.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/sdl_input_controller.h">code/software/sdl_input_controller.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/socket_util.cpp">code/software/socket_util.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/socket_util.h">code/software/socket_util.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/solver.cpp">code/software/solver.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/solver.h">code/software/solver.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/test_bignum.cpp">code/software/test_bignum.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile.cpp">code/software/tile.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile.h">code/software/tile.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_client.cpp">code/software/tile_client.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_client.h">code/software/tile_client.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_request_heap.cpp">code/software/tile_request_heap.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_request_heap.h">code/software/tile_request_heap.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_request_packet.h">code/software/tile_request_packet.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_server.cpp">code/software/tile_server.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_server.h">code/software/tile_server.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/viewport.h">code/software/viewport.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/complex.h">code/software/complex.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/cpu_solver.cpp">code/software/cpu_solver.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_header.h">code/software/tile_header.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/viewport.cpp">code/software/viewport.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_manager.cpp">code/software/tile_manager.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/application.h">code/software/application.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/renderer.cpp">code/software/renderer.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/renderer.h">code/software/renderer.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/tile_manager.h">code/software/tile_manager.h</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/application.cpp">code/software/application.cpp</a></span></p><p class="c0"><span class="c9"><a class="c11" href="code/software/constants.h">code/software/constants.h</a></span></p><p class="c0 c15"><span class="c3"></span></p></div></body></html>