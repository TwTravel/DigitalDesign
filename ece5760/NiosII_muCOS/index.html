<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>NiosII GCC with MicroC/OS</title>
</head>

<body>
 <h2>NiosII GCC with MicroC/OS</h2>
 <p>To find out more generally about MicroC/OS, read the book listed below by Labrosse. There is also a partial API <a href="uC_Functions.html">summary</a> by Nancy Minderman at the University of Alberta and a terse summary from <a href="../MicroCOS/QuickRefChartV251-Color.pdf">Micrium</a>. There is a <a href="../../../../../studies.ac.upc.edu/EPSC/SED/Apuntes/uCOS-II-RefMan.pdf">very complete list</a> of functions from <a href="../../../../../www.ac.upc.es/default.htm">Departamento de Arquitectura de Computadores (DAC)</a> en la  Escola Polit&egrave;cnica Superior de Castelldefels (EPSC) (campus de la  Universitat Polit&egrave;cnica de Catalunya).&nbsp;</font>
  There is a good MicroC/OS <a href="../../../../../www.rabbitsemiconductor.com/documentation/docs/modules/ucos2/default.htm">summary</a> at Zworld, but you will have to filter out the device-specific material.
</p>
 <p>MicroC/OS allows you to define several functions in C, each of which can execute as an independent thread or task. Each task runs at a different priority, and thinks that it owns the CPU. Lower priority tasks can be prempted by higher priority tasks at any time. Higher priority tasks use operating system services (such as a delay or event) to allow  lower priority tasks to execute. There are operating system services provided for task managment, inter-task communication,  memory managment, and for timing. <br>
 MicroC/OS services include:</p>
 <ul>
   <li>Semaphores and Mutual Exclusion Semaphores (to reduce priority inversions)</li>
   <li>Event Flags</li>
   <li>Message Mailboxes and Queues</li>
   <li>Task Management (Create, Delete, Change Priority, Suspend/Resume etc.)</li>
   <li>Fixed Sized Memory Block management</li>
   <li>Time and Timer Management</li>
 </ul>
 <p>Interrupt service routines can be integrated into MicroC/OS programs as long as the OS is informed of the interrupt. ISRs should be short and essentially just signal a normal (high priority) task to execute. See example 3 below. </p>
 <p><strong>Examples</strong>:</p>
<ol>
   <li><strong>Three MicroC/OS tasks with DDS, semaphore, and message passing. </strong><br>
     The first example uses a NiosII cpu with JTAG UART, interval timer, two input and two output ports, and an LCD port. The timer was set to default to 1 mSec in the SOPC. This setting seems to be picked up by the OS library builder in the IDE program. For real applications, it should probably be set to 10 mSec. Changing the timer in the SOPC to 10 mSec, rebuilding the hardware, then recompiling the GCC program automatically sets the MicroC/OS system tick to 10 mSec. The <code><a href="TestBigNios_time_limited.sof">sof</a></code> and <code><a href="bigNios.ptf">ptf</a></code> files define the system. <br>
     <img src="SOPCcpu.png" width="812" height="318">     <br>
     The <a href="TestBigNios.v">top level module</a> connects <code>Out0</code> to a DDS (direct digital synthesis) unit for sine wave production. <code>In0</code> is connected to the DE2 switches and the 8-bit <code>In1</code> connected to the pushbuttons. See <a href="../../../../../instruct1.cit.cornell.edu/courses/ece576/NiosII_C/index.html">NiosII C examples</a>, example #3 for more information on the DDS. Note that in <code><a href="system.h">system.h</a></code> (generated by the library builder) that the names of the i/o ports are UPPERCASED.  After the workspace is defined in the IDE, the system library properties need to be set up for the RTOS as shown below. Clicking the <code>RTOS Options</code> button allows you to choose exactly what OS modules you want to include. The default is to include every module, which results in a minimum 120 kByte executable. The Altera <a href="../../../../../altera.com/literature/tt/tt_nios2_MicroC_OSII_tutorial.pdf">Tutorial</a> gives more detail on setting up the system library. <br>
     <img src="SysLibProp.png" width="956" height="583"><br>
     The <a href="test1_ucosii.c">GCC program</a> structure is very simple:
	 <ul>
     <li>The <code>main</code> defines OS data structures and tasks. OS data structures (in this example, a message queue and a semaphore) used by more than one task need to be global. </li>
	 
	 <li>Each task is written so that it never terminates. This implies that task local variables are effectively static. The task stack must be made big enough to hold all local variables (including those defined in functions within tasks) and the task context when another task is running. </li>
	 <li> Task 1 controls a hardware DDS unit running in the top level Verilog module. The DE2 toggle switches control which octave is played. </li>
	 <li>Task 1 sends a message to Task 2, which prints the message.</li>
	 <li>Task 1 controls Task 3 via a semaphore so that Task 3 runs every time Task 1 does, unless Task 1 suspends Task 3 using a pushbutton.</li>
	 <li>Task 2 waits for a message, prints it and waits again</li>
	 <li>Task 3 waits for a semaphore, prints the system time, and waits again</li>
	 </ul> 
	 Note that several system calls in the program cause a context change. The call <code>OSTimeDlyHMSM</code> causes Task 1 to block for a time interval, but does not affect the execution of other tasks. <code>OSQPend</code> causes Task 2 to wait for a message in the queue, while <code>OSSemPend</code> causes Task 2 to wait for a signal from Task 1. If a task does not call an OS service which causes it to wait, then no lower priority task will ever execute! <br>
	 <br>
	 A slight modification to the <a href="TestBigNiosA.v">top-level Verilog module</a> connects output port Out1 to the green LEDs. The <a href="test1a_ucosii.c">GCC program</a> was modified to include a fourth, low priority task, which does not block using OS calls, but runs at full speed. With task 1 pacing the first three tasks at one/sec, the LED blink rate suggests that  task 4 is running about a million times/sec. When task 1 is running at about 140/sec (<code>OSTimeDly</code> set to 7 mSec), task 4 never gets a chance to run because task processing, context switches and OS overhead is eating the cpu. <p>
   </li>
   <li><strong>Using the LCD</strong>. <br>
   The example uses the same cpu as above, but the last two lines of the top-level Verilog module were modified to turn on the LCD alphanumeric display. The device driver for the LCD is named in <a href="system.h">system.h</a> and seems to be recognized as a UNIX-style stream file device by the GCC library <code>stdio.h</code>. Using it is just a matter of opening a device using <code>fopen</code> and writing to it using <code>fprintf</code>. The device driver recognizes <a href="../../../../../www.isthe.com/chongo/tech/comp/ansi_escapes.html">ansi escape codes</a> to control the cursor position. This <a href="LCDa_ucosii.c">GCC program</a> is a modification of example 1. Task 1 can clear the LCD when KEY1 is pushed and Task 3 prints its stack size to <code>stdout</code> and the OS tick time to the LCD. The LCD file device is opened in <code>main</code>. The frequency accuracy of the DDS was reduced to increase its dynamic range in frequency. As shown, the DDS can reproduce sine waves from DC to over one MHz with an accuracy of about .012 Hz at low frequencies and an accuracy limited by the crystal at high frequencies. </li><br>
   <li><strong>Interrupt Service Routine (ISR) in MicroC/OS</strong>. <br>
   This example uses the same cpu as above, but with the addition of a second timer (timer1). Timer0 cannot be touched because it is used by the internal OS time-tick function. The <a href="ISR_ucosii.c">GCC program</a> was modified so that task 4 runs at highest priority, but waits for a semaphore which is signaled by the timer1 ISR. MicroC/OS needs to know you are in an interrupt, but it turns out that  the necessary MicroC/OS bookkeeping is encapsulated in the Altera interrupt handler, so that only user code needs to be in the ISR. This means that you don't need to save context or include <code>OSIntEnter()</code> or <code>OSIntExit()</code> in the ISR because the interrupt handler is aware of the operating system and handles it. The details can be found in the main interrupt handler, <code>alt_irq_handler()</code> (To find the source file, open the tabs in the left-most IDE panel: <code>syslib  / DeviceDrivers[nios] / altera_hal / HAL / src)</code>.  More details on saving context are in <code>alt_irq_entry.S </code>(To find the source file, open the tabs: <code>syslib / DeviceDrivers[nios] / altera_nios2 / HAL / src</code>).  The whole project is <a href="microCOS/MicroCOSwithISR.zip">zipped here</a>. <br>
   <br>
   How fast can we make it interrupt before the multitasking messes up? You can set the optimization level by right-clicking the project icon and going to <code>properties</code>. From there, choose NiosII complier options. With optimization set to <code>-O0</code> (the default setting), reducing the number of ticks to timeout for timer1 to 0x1800 causes the system to crash. Setting the number of ticks to timeout for timer1 to 0x2000 allows multitasking of all four tasks to work. Setting the number of ticks to timeout for timer1 to 0x1d00 allows task 4 and task 1 to run, but not the lower priority tasks 2 and 3. With optimization set to <code>-O3</code> (the highest) and no debugging, multitasking works with a setting of 0x1900, but fails at 0x1800. Thus, it looks like it takes about 6100 cycles for the ISR handling, internal timer0 functions, and context switching, so we can sustain (with these simple tasks) perhaps 7800 interrupts/second in MicroC/OS. Very fast functions, such as DDS, should be put in hardware, but button push detection and other sporadic events can be interrupt-driven. </li>
   <br>
   <li><strong>LCD written from 3 tasks, with Mutex protection</strong><br>
     This example uses the same cpu as in example 3 above. The <a href="mutex_ucosii.c">GCC program</a> was modified so that tasks 2, 3 and 4 all write to the LCD. A <a href="../../../../../en.wikipedia.org/wiki/Mutual_exclusion">mutex</a> is used to give each task sole control of the LCD until it is finished writing its string. The task owning the mutex has its priority temporarily boosted to avoid priority inversion. <br>
   </li>
</ol>
 <hr>
   <p><strong>References
</strong></p>
   <p>Altera <a href="../../../../../altera.com/literature/hb/nios2/n2sw_nii52008.pdf">MicroC/OS </a> and <a href="../../../../../altera.com/literature/tt/tt_nios2_MicroC_OSII_tutorial.pdf">Tutorial</a> </p>
   <p><a href="../../../../../www.micrium.com/default.htm">Micrium</a> is the MicroC/OS vendor</p>
   <p>MicroC/OS-II The Real Time Kernel, by Jean Labrosse, RD books, second edition, 2002</p>
   <p><a href="uC_Functions.html">MicroC/OS function summary</a> and API (linked from <a href="../../../../../www.ece.ualberta.ca/~cmpe401/fall2004/labs/lab3/lab3.html">http://www.ece.ualberta.ca/~cmpe401/fall2004/labs</a>/docs/uC_Functions.html)</p>
   <p><a href="../../../../../www.micrium.com/support/application_notes.html">Micrium Application Notes</a>: </p>
   <ul>
     <li>AN3000 TCP/IP on NiosII </li>
     <li><font color="#400040">AN5001</font><font color="#cc6600"></font><font color="#cc6600" face="Arial Black"> &micro;C/</font><font color="#0000cc" face="Arial Black">GUI</font><b> and the Altera Nios II Soft Core Processor</b></li>
     <li>AN6000<b> <font color="#cc6600" face="Arial Black">&micro;C/</font><font color="#0000cc" face="Arial Black">FS</font><strong> and the Altera Nios II Soft Core Processor</strong></b></li>
   </ul>
   <p>MicroC/OS info from EPSC </p>
   <ul>
     <li><a href="../../../../../studies.ac.upc.edu/EPSC/SED/Apuntes/uCOS-II.pdf">Summary slides </a></li>
     <li><a href="../../../../../studies.ac.upc.edu/EPSC/SED/Apuntes/uCOS-II-RefMan.pdf">Function Reference</a> This appears to be Chapter 16 of Labrosse's book. </li>
   </ul>
   <hr>
   <p>Copyright Cornell University June 2006 </p>
   <p>&nbsp;</p>
</body>
</html>
